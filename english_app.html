<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" sizes="512x512" href="favicon.png">
    <title>English App</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dropbox.js/10.34.0/Dropbox-sdk.min.js"></script>
    <style>
        body {
            font-family: 'TwitterChirp', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            background-color: #fff;
            color: #000;
        }
        header {
            display: flex;
            align-items: center;
            padding: 10px 20px;
            border-bottom: 1px solid #ddd;
            background: #fff;
            position: relative;
            z-index: 99;
        }
        .hamburger-btn {
            display: none;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #d32f2f;
            margin-right: 15px;
        }
        .hamburger-btn:hover {
            color: #b71c1c;
        }
        @media (max-width: 768px) {
            .hamburger-btn {
                display: block;
            }
        }
        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #d32f2f;
        }
        .search {
            flex: 1;
            margin: 0 20px;
        }
        .search input {
            width: 100%;
            padding: 8px;
            border-radius: 20px;
            border: 1px solid #ddd;
            background: #fff;
            color: #000;
        }
        .layout {
            display: flex;
            height: calc(100vh - 60px);
        }
        .left-sidebar {
            width: 250px;
            padding: 20px;
            border-right: 1px solid #ddd;
            background: #f8f9fa;
            overflow-y: auto;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        @media (max-width: 768px) {
            .left-sidebar {
                position: fixed;
                left: 0;
                top: 60px;
                height: calc(100vh - 60px);
                width: 250px;
                transform: translateX(-100%);
                box-shadow: 2px 0 10px rgba(0,0,0,0.1);
                z-index: 98;
            }
            .left-sidebar.active {
                transform: translateX(0);
            }
        }
        .left-sidebar nav button {
            display: block;
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            background: none;
            border: none;
            color: #000;
            text-align: left;
            border-radius: 10px;
            font-size: 18px;
        }
        .left-sidebar nav button:hover {
            background: #e9ecef;
        }
        .left-sidebar nav button.active {
            background: #d32f2f;
            color: #fff;
        }
        /* Category group and subcategory styles */
        .category-group {
            margin-bottom: 6px;
        }
        .category-group > .category-btn {
            font-weight: 600;
        }
        .subcat-list {
            margin-top: 6px;
            margin-bottom: 8px;
            transition: max-height 0.18s ease;
        }
        .subcategory-btn {
            display: block;
            width: calc(100% - 8px);
            padding: 8px 10px;
            margin: 4px 0;
            background: transparent;
            border: none;
            text-align: left;
            color: #333;
            font-size: 15px;
            border-radius: 8px;
            cursor: pointer;
            padding-left: 14px;
        }
        .subcategory-btn:hover {
            background: #e9ecef;
        }
        .subcategory-btn.active {
            background: #d32f2f;
            color: #fff;
        }
        .exercise-counter {
            background: #d32f2f;
            color: #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            margin-right: 15px;
        }
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #fff;
        }
        @media (max-width: 768px) {
            .main-content {
                padding: 15px;
            }
        }
        .compose {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            gap: 10px;
        }
        @media (max-width: 768px) {
            .compose {
                flex-direction: column;
                align-items: stretch;
            }
        }
        .compose button {
            background: #d32f2f;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
        }
        .compose button:hover {
            background: #b71c1c;
        }
        .controls {
            display: flex;
            gap: 10px;
        }
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
            }
        }
        .controls select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
            background: #fff;
            color: #000;
        }
        .modal-overlay {
            display: none;
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.3);
            z-index: 97;
        }
        .modal-overlay.active {
            display: block;
        }
        fieldset {
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 15px;
            padding: 10px;
        }
        legend {
            font-weight: bold;
            color: #d32f2f;
        }
        .filter-group {
            margin-bottom: 10px;
        }
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .feed .tweet {
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            background: #fff;
            position: relative;
        }
        .tweet-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .tweet-header .difficulty {
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            margin-right: 10px;
        }
        .easy { background: green; color: #fff; }
        .medium { background: orange; color: #fff; }
        .hard { background: red; color: #fff; }
        .tweet-header .category {
            color: #d32f2f;
            margin-right: 10px;
        }
        .tweet-header .favorite-btn {
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #ffd700;
            margin-left: auto;
        }
        .tweet-header .favorite-btn:hover {
            color: #ffed4e;
        }
        .tweet-header .annotation-btn {
            background: none;
            border: 1px solid #ddd;
            color: #000;
            padding: 2px 6px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 10px;
        }
        .tweet-header .annotation-btn:hover {
            background: #f8f9fa;
        }
        .tweet-content h4 {
            margin: 0 0 10px 0;
            color: #000;
        }
        .tweet-content img {
            max-width: 100%;
            height: auto;
            margin: 10px 0;
            border-radius: 10px;
        }
        .tweet-content p {
            margin: 10px 0;
            color: #000;
        }
        .tweet-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .tweet-actions button {
            background: none;
            border: 1px solid #ddd;
            color: #000;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }
        .tweet-actions button:hover {
            background: #f8f9fa;
        }
        .feito-btn {
            background: #dc3545;
            color: #fff;
        }
        .feito-btn.in-progress {
            background: #ffc107;
            color: #000;
        }
        .feito-btn.in-progress:hover {
            background: #e0a800;
            color: #000;
        }
        .feito-btn.done {
            background: #28a745;
            color: #fff;
        }
        .feito-btn.done:hover {
            background: #33623e;
            color: #fff;
        }
        .annotation-btn.has-annotations {
            background: #ffc107;
            color: #000;
        }
        .responder-btn, .limpar-btn {
            background: none;
            border: 1px solid #ddd;
            color: #000;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }
        .responder-btn:hover, .limpar-btn:hover {
            background: #f8f9fa;
        }
        .answer-accordion {
            margin-top: 10px;
        }
        .accordion-toggle {
            background: #d32f2f;
            color: #fff;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }
        .accordion-toggle:hover {
            background: #b71c1c;
        }
        .accordion-content {
            margin-top: 10px;
        }
        .accordion-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fff;
            color: #000;
            padding: 20px;
            border: 1px solid #ddd;
            width: 80%;
            max-width: 500px;
            border-radius: 10px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 101;
            max-height: 80vh;
            overflow-y: auto;
        }
        @media (max-width: 768px) {
            .modal-content {
                width: 90%;
                max-width: 100%;
            }
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover {
            color: #000;
        }
        .modal-content label {
            display: block;
            margin-top: 10px;
            color: #000;
        }
        .modal-content input, .modal-content textarea, .modal-content select {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #fff;
            color: #000;
            box-sizing: border-box;
        }
        .modal-content button {
            margin-top: 10px;
            padding: 10px 15px;
            background: #d32f2f;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .modal-content button:hover {
            background: #b71c1c;
        }
        /* UI polish: unified buttons and flashcards styles */
        .btn { padding: 8px 12px; border-radius:6px; border: none; cursor: pointer; background: #d32f2f; color: #fff; }
        .btn.secondary { background: #fff; color: #d32f2f; border:1px solid #d32f2f; }
        .header-btn { padding:6px 10px; margin-left:8px; border-radius:6px; background: #d32f2f; color:#fff; border:none; cursor:pointer; }
        .header-btn:hover { background:#b71c1c; }
        /* Review button defaults to neutral until there are pending reviews */
        #reviewBtn { background: #e0e0e0; color: #222; }
        #reviewBtn:hover { background: #d5d5d5; }
        #reviewBtn.pending { background: #b71c1c !important; color: #fff !important; }

        /* Flashcards modals wider and centered */
        #flashcardsModal .modal-content, #newBatchModal .modal-content, #studyModal .modal-content {
            max-width: 760px;
            width: 92%;
            padding: 18px;
            border-radius: 12px;
        }

        /* Flashcards controls */
        #flashcardsModal .modal-content > div { display:flex; align-items:center; }
        #batchSelect { padding:8px; border-radius:6px; border:1px solid #ddd; margin-left:8px; }
        #flashcardsManage { margin-top:12px; }

        .card-row input[type=text] { width: calc(50% - 12px); display:inline-block; margin-right:8px; }
        .card-row label { display:block; margin-top:6px; font-weight:600; }
        .card-row .remove-card-btn { background:#777; color:#fff; padding:6px 8px; border-radius:6px; margin-top:8px; }

        /* Study area */
        #cardFront, #cardBack { background:#fff; box-shadow:0 2px 6px rgba(0,0,0,0.06); }
        #cardFront { min-height:100px; display:flex; align-items:center; justify-content:center; }
        #cardBack { min-height:80px; padding:12px; border-radius:6px; }
        #studyArea button { padding:8px 10px; border-radius:6px; }

        /* responsive tweaks */
        @media (max-width:600px) {
            .card-row input[type=text] { width:100%; margin-right:0; }
            #flashcardsModal .modal-content { width:96%; }
        }
        .alternative-input {
            display: flex;
            align-items: center;
            margin-top: 5px;
        }
        .alternative-input input {
            flex: 1;
            margin-right: 10px;
        }
        .remove-alt {
            background: #dc3545;
            color: #fff;
            border: none;
            padding: 2px 5px;
            cursor: pointer;
        }
        .alt-text.rasurada {
            text-decoration: line-through;
            color: gray;
        }
        .multi-image-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
            gap: 10px;
        }
        .multi-image-item:last-child {
            border-bottom: none;
        }
        .multi-image-thumbnail {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 5px;
            cursor: pointer;
        }
        .multi-image-info {
            flex: 1;
        }
        .multi-image-info input {
            width: 100%;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 12px;
        }
        .multi-image-remove {
            background: #dc3545;
            color: #fff;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        .multi-image-remove:hover {
            background: #c82333;
        }
        .rasurar-btn {
            margin-right: 5px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            padding: 0;
        }
        .rasurar-btn:hover {
            background: rgba(255, 107, 107, 0.2);
            border-radius: 4px;
        }
        .alt-label input {
            vertical-align: middle;
        }
        .alt-label {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .alt-text {
            margin-right: 10px;
        }
        .tags {
            margin-top: 5px;
            font-size: 12px;
            color: #666;
        }
        .tag {
            display: inline-block;
            background: #e9ecef;
            padding: 2px 6px;
            margin-right: 5px;
            border-radius: 4px;
            color: #000;
        }
        .tag-selector {
            margin: 15px 0;
        }
        .tag-selector-label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }
        .tag-search-section {
            margin-bottom: 12px;
        }
        .tag-search-input {
            display: block;
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            box-sizing: border-box;
            margin-bottom: 6px;
            transition: border-color 0.2s ease;
        }
        .tag-search-input:focus {
            outline: none;
            border-color: #d32f2f;
            background: #fff5f5;
        }
        .tag-search-info {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
        }
        .existing-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
            max-height: 200px;
            overflow-y: auto;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }
        .tag-chip {
            display: inline-flex;
            align-items: center;
            background: #e9ecef;
            border: 2px solid #ddd;
            padding: 6px 10px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
            user-select: none;
        }
        .tag-chip:hover {
            background: #dee2e6;
            border-color: #999;
        }
        .tag-chip.selected {
            background: #d32f2f;
            border-color: #d32f2f;
            color: #fff;
            font-weight: bold;
        }
        .tag-chip.selected:hover {
            background: #b71c1c;
            border-color: #b71c1c;
        }
        .no-tags-message {
            text-align: center;
            padding: 20px 10px;
            color: #999;
            font-style: italic;
            font-size: 13px;
        }
        .new-tag-section {
            border-top: 1px solid #ddd;
            padding-top: 12px;
            margin-top: 12px;
        }
        .new-tag-section-label {
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            font-size: 13px;
            display: block;
        }
        .new-tag-input {
            display: block;
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
            margin-bottom: 8px;
        }
        .new-tag-input:focus {
            outline: none;
            border-color: #d32f2f;
        }
        .new-tag-hint {
            font-size: 12px;
            color: #999;
            margin-bottom: 8px;
        }
        .selected-tags-display {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
            padding: 8px;
            background: #fff5f5;
            border-radius: 4px;
            min-height: 30px;
            border: 1px solid #d32f2f;
        }
        .selected-tags-display .tag-chip {
            background: #d32f2f;
            color: white;
            border: 1px solid #d32f2f;
        }
        .selected-tags-display .tag-chip:hover {
            background: #b71c1c;
        }
        .hidden {
            display: none;
        }
        .dropdown-menu {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 100;
            padding: 5px;
        }
        .dropdown-menu button {
            display: block;
            width: 100%;
            margin: 2px 0;
            background: none;
            border: none;
            color: #000;
            text-align: left;
        }
        .dropdown-menu button:hover {
            background: #f8f9fa;
        }
        .menu-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
        }
        .menu-btn {
            background: #fff;
            border: 1px solid #ddd;
            color: #000;
            padding: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
        }
        .stats-section {
            margin-top: 30px;
        }
        .stats-section h2 {
            text-align: center;
            color: #d32f2f;
        }
        .stats-section #addStatsBtn {
            margin-bottom: 20px;
            background: #d32f2f;
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
        }
        .stats-entry {
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 10px;
            background: #fff;
        }
        .stats-entry h3 {
            color: #d32f2f;
        }
        .stats-entry p {
            margin: 5px 0;
            color: #000;
        }
        .stats-entry button {
            margin-right: 10px;
            background: #6c757d;
            color: #fff;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }
        .stats-entry button:hover {
            background: #5a6268;
        }
        .simulado-section {
            margin-top: 30px;
        }
        .simulado-section h2 {
            text-align: center;
            color: #d32f2f;
        }
        .simulado-section #submitSimulado {
            margin-bottom: 20px;
            background: #d32f2f;
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
        }
        .simulado-question {
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 10px;
            background: #fff;
        }
        .timer-section {
            background: #fff5f5;
            border: 1px solid #d32f2f;
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }
        .timer-toggle {
            text-align: right;
            margin-bottom: 5px;
        }
        .timer-toggle-btn {
            background: none;
            border: none;
            color: #d32f2f;
            cursor: pointer;
            font-size: 14px;
        }
        .timer-toggle-btn:hover {
            text-decoration: underline;
        }
        .timer-section.collapsed .timer-controls,
        .timer-section.collapsed .timer-history,
        .timer-section.collapsed .timer-display {
            display: none;
        }
        .timer-display {
            font-size: 32px;
            font-weight: bold;
            color: #d32f2f;
            text-align: center;
            margin: 10px 0;
        }
        .timer-controls {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 10px 0;
        }
        .timer-btn {
            background: #d32f2f;
            color: #fff;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .timer-btn:hover {
            background: #b71c1c;
        }
        .timer-btn.pause {
            background: #ffc107;
            color: #000;
        }
        .timer-btn.pause:hover {
            background: #ffb300;
        }
        .timer-btn.reset {
            background: #dc3545;
        }
        .timer-btn.reset:hover {
            background: #c82333;
        }
        .timer-btn.complete {
            background: #28a745;
        }
        .timer-btn.complete:hover {
            background: #218838;
        }
        .timer-history {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
        }
        .timer-history h5 {
            margin: 0 0 8px 0;
            color: #d32f2f;
            font-size: 14px;
        }
        .history-entry {
            font-size: 12px;
            color: #666;
            padding: 4px 0;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .history-entry:last-child {
            border-bottom: none;
        }
        .history-entry span {
            font-weight: bold;
            color: #000;
        }
        .delete-time-btn {
            background: #dc3545;
            color: #fff;
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }
        .delete-time-btn:hover {
            background: #c82333;
        }
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            gap: 5px;
        }
        .pagination button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            background: #fff;
            color: #000;
            cursor: pointer;
            border-radius: 5px;
        }
        .pagination button:hover {
            background: #f8f9fa;
        }
        .pagination button.active {
            background: #d32f2f;
            color: #fff;
        }
        .pagination button:disabled {
            background: #e9ecef;
            cursor: not-allowed;
        }
        .simulado-stats, .simulado-history {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 10px;
            background: #f8f9fa;
        }
        .simulado-stats h3, .simulado-history h3 {
            margin-top: 0;
            color: #d32f2f;
        }
        #createSimuladoBtn {
            background: #d32f2f;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 20px;
        }
        #createSimuladoBtn:hover {
            background: #b71c1c;
        }
        #clearHistoryBtn {
            background: #dc3545;
            color: #fff;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            margin-bottom: 10px;
        }
        #clearHistoryBtn:hover {
            background: #c82333;
        }
        .simulado-question.correct {
            border-left: 5px solid #28a745;
        }
        .simulado-question.incorrect {
            border-left: 5px solid #dc3545;
        }
        .result-alternatives {
            margin-top: 10px;
        }
        .alt-result {
            padding: 5px;
            margin: 2px 0;
            border-radius: 3px;
        }
        .correct-answer {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .wrong-answer {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        #simuladoList button {
            background: #d32f2f;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #simuladoList button:hover {
            background: #b71c1c;
        }
        .delete-simulado-btn {
            background: #dc3545;
            color: #fff;
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            margin-left: 10px;
        }
        .delete-simulado-btn:hover {
            background: #c82333;
        }
        .random-mode-btn {
            background: #6c757d;
            color: #fff;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .random-mode-btn:hover {
            background: #5a6268;
        }
        .random-mode-btn.active {
            background: #28a745;
        }
        .random-exercise-container {
            display: none;
            border: 2px solid #d32f2f;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            background: #fff5f5;
        }
        .random-exercise-container.show {
            display: block;
        }
        .random-exercise-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .random-exercise-header h3 {
            margin: 0;
            color: #d32f2f;
        }
        .random-close-btn {
            background: #dc3545;
            color: #fff;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .random-close-btn:hover {
            background: #c82333;
        }
        .random-exercise-nav {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
        .random-nav-btn {
            background: #d32f2f;
            color: #fff;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
        }
        .random-nav-btn:hover {
            background: #b71c1c;
        }
        .random-nav-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .random-counter {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-top: 10px;
        }
    </style>
    <style>
    .header-btn.pending { background: #b71c1c !important; color: white !important; }
    </style>
</head>
<body>
<header>
  <button class="hamburger-btn" id="hamburgerBtn">‚ò∞</button>
  <div class="exercise-counter" id="exerciseCounter">0</div>
  <div class="logo"><img src="favicon.png" alt="Logo" style="height: 24px; margin-right: 10px;">English App</div>
        <div class="search">
        <input type="text" id="searchInput" class="search-input" placeholder="Buscar por categoria ou #tag (ex: #Textos, #TOEFL)">
    </div>
  <button class="random-mode-btn" id="randomModeBtn" title="Modo Aleat√≥rio">üé≤</button>
        <button id="flashcardsBtn" class="header-btn" title="Flashcards">üÉè Flashcards</button>
            <button id="reviewBtn" class="header-btn" title="Revis√µes Pendentes">üïí <span id="reviewCount" style="font-weight:700; margin-left:6px;">0</span></button>
</header>

<div class="modal-overlay" id="modalOverlay"></div>

<div class="layout">
    <aside class="left-sidebar" id="leftSidebar">
        <nav>
            <button class="category-btn active" data-category="Todos">Todos</button>

            <div class="category-group">
                <button class="category-btn" data-category="Produ√ß√£o Textual">Produ√ß√£o Textual ‚ñæ</button>
                <div class="subcat-list" data-parent="Produ√ß√£o Textual" style="display:none; margin-left:10px;">
                    <button class="subcategory-btn" data-parent="Produ√ß√£o Textual" data-category="Textos & Tradu√ß√µes">Textos & Tradu√ß√µes (En-Pt / Pt-En)</button>
                    <button class="subcategory-btn" data-parent="Produ√ß√£o Textual" data-category="Notas">Notas</button>
                    <button class="subcategory-btn" data-parent="Produ√ß√£o Textual" data-category="Challenges">Challenges</button>
                    <button class="subcategory-btn" data-parent="Produ√ß√£o Textual" data-category="Relat√≥rios">Relat√≥rios</button>
                </div>
            </div>

            <div class="category-group">
                <button class="category-btn" data-category="Gram√°tica Pura">Gram√°tica Pura ‚ñæ</button>
                <div class="subcat-list" data-parent="Gram√°tica Pura" style="display:none; margin-left:10px;">
                    <button class="subcategory-btn" data-parent="Gram√°tica Pura" data-category="N√≠vel Iniciante">N√≠vel Iniciante (A1-A2)</button>
                    <button class="subcategory-btn" data-parent="Gram√°tica Pura" data-category="N√≠vel Intermedi√°rio">N√≠vel Intermedi√°rio (B1-B2)</button>
                    <button class="subcategory-btn" data-parent="Gram√°tica Pura" data-category="N√≠vel Avan√ßado">N√≠vel Avan√ßado (C1-C2)</button>
                    <button class="subcategory-btn" data-parent="Gram√°tica Pura" data-category="Vocabul√°rio">Vocabul√°rio</button>
                </div>
            </div>

            <div class="category-group">
                <button class="category-btn" data-category="Preparat√≥rio TOEFL">Preparat√≥rio TOEFL ‚ñæ</button>
                <div class="subcat-list" data-parent="Preparat√≥rio TOEFL" style="display:none; margin-left:10px;">
                    <button class="subcategory-btn" data-parent="Preparat√≥rio TOEFL" data-category="Dicas & Estrat√©gias">Dicas & Estrat√©gias</button>
                </div>
            </div>

            <br>
            <button class="stats-btn" id="statsBtn">Stats</button>
            <br><br>
            <button class="simulado-btn" id="simuladoBtn">Simulado</button>
            <br><br>
            <button class="stats-btn" id="tagsBtn">Etiquetas</button>
            <br><br>
            <button id="exportBtn">Exportar Dados</button>
            <br><br>
            <button id="importBtn">Importar Dados</button>
            <br><br>
            <button id="storageBtn" style="background: #ff9800; color: white;">üìä Storage</button>
        </nav>
    </aside>
  <main class="main-content">
        <div class="random-exercise-container" id="randomExerciseContainer">
            <div class="random-exercise-header">
                <h3>üé≤ Modo Aleat√≥rio</h3>
                <button class="random-close-btn" id="closeRandomBtn">Fechar</button>
            </div>
            <div id="randomExerciseContent"></div>
            <div class="random-exercise-nav">
                <button class="random-nav-btn" id="prevRandomBtn">‚Üê Anterior</button>
                <button class="random-nav-btn" id="nextRandomBtn">Pr√≥ximo ‚Üí</button>
                <button class="random-nav-btn" id="reviewOkBtn" style="display:none; background:#b71c1c; color:#fff;">OK / Revisado</button>
            </div>
            <div class="random-counter">
                <span id="randomCounter">0/0</span>
            </div>
        </div>
        <div class="compose">
            <button class="new-exercise-btn" id="newExerciseBtn">Novo Exerc√≠cio</button>
      <div class="controls">
        <select id="sortSelect" class="sort-select">
          <option value="recent">Mais recentes</option>
          <option value="oldest">Mais antigas</option>
          <option value="easy-first">Mais f√°ceis</option>
          <option value="hard-first">Mais dif√≠ceis</option>
        </select>
        <select id="statusSelect" class="status-select">
          <option value="all">Todos</option>
          <option value="done">Feitos</option>
          <option value="in-progress">Em Progresso</option>
          <option value="not-done">N√£o Feitos</option>
          <option value="favorites">Favoritos</option>
        </select>
      </div>
    </div>
    <div class="feed" id="exerciseList">
      <!-- Exercises will be displayed here -->
    </div>
    <div id="pagination" class="pagination"></div>
    <div class="stats-section" id="statsSection" style="display: none;">
      <h2>Estat√≠sticas</h2>
      <button id="addStatsBtn">Adicionar Estat√≠sticas</button>
      <div id="statsList"></div>
    </div>
    <div class="simulado-section" id="simuladoSection" style="display: none;">
      <h2>Simulado</h2>
      <div class="simulado-stats">
        <h3>Estat√≠sticas</h3>
        <p>Total de Simulados: <span id="totalSimulados">0</span></p>
        <p>M√©dia de Acertos: <span id="mediaAcertos">0%</span></p>
        <p>Tempo M√©dio: <span id="tempoMedio">0 min</span></p>
      </div>
      <div class="simulado-history">
        <h3>Hist√≥rico de Resultados</h3>
        <button id="clearHistoryBtn">Limpar Hist√≥rico</button>
        <div id="historyList"></div>
      </div>
      <button id="createSimuladoBtn">Criar Novo Simulado</button>
      <div id="simuladoList"></div>
      <button id="submitSimulado" style="display: none;">Enviar Simulado</button>
    </div>
  </main>
</div>

<!-- Modal for annotations -->
<div id="annotationModal" class="modal">
  <div class="modal-content">
    <span class="close" id="closeModal">&times;</span>
    <h2>Anota√ß√µes</h2>
    <textarea id="annotationText" rows="10" placeholder="Digite suas anota√ß√µes aqui..."></textarea>
    <button id="saveAnnotation">Salvar Anota√ß√£o</button>
  </div>
</div>

<!-- Modal for editing -->
<div id="editModal" class="modal">
  <div class="modal-content">
    <span class="close" id="closeEditModal">&times;</span>
    <h2>Editar Exerc√≠cio</h2>
    <label for="editTitle">T√≠tulo do Exerc√≠cio:</label>
    <input type="text" id="editTitle">

    <label for="editDifficulty">Dificuldade:</label>
    <select id="editDifficulty">
      <option value="easy">F√°cil</option>
      <option value="medium">M√©dio</option>
      <option value="hard">Dif√≠cil</option>
    </select>

    <label for="editCategory">Categoria:</label>
    <select id="editCategory">
            <option value="Produ√ß√£o Textual">Produ√ß√£o Textual</option>
            <option value="Gram√°tica Pura">Gram√°tica Pura</option>
            <option value="Preparat√≥rio TOEFL">Preparat√≥rio TOEFL</option>
    </select>

    <label for="editImage">Upload da Foto (opcional):</label>
    <input type="file" id="editImage" accept="image/*">

    <label for="editExerciseText">Texto do Exerc√≠cio (opcional):</label>
    <textarea id="editExerciseText" rows="5"></textarea>

    <label for="editAnswerImage">Imagem da Resolu√ß√£o (opcional):</label>
    <input type="file" id="editAnswerImage" accept="image/*">
    <label for="editAudio">√Åudio do Exerc√≠cio (opcional):</label>
    <input type="file" id="editAudio" accept="audio/*">
    <div id="editAudioPreview" style="margin-top:8px;"></div>
    <label for="editAnswerAudio">√Åudio da Resolu√ß√£o (opcional):</label>
    <input type="file" id="editAnswerAudio" accept="audio/*">
    <div id="editAnswerAudioPreview" style="margin-top:8px;"></div>
    <label style="margin-top:8px;"><input type="checkbox" id="editReviewFlag"> Marcar para revis√£o</label>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
            <label style="margin:0;">Recorr√™ncia:</label>
            <select id="editRecurrence">
                <option value="">Nenhum</option>
                <option value="daily">Diariamente</option>
                <option value="weekly">Semanalmente</option>
                <option value="monthly">Mensalmente</option>
            </select>
            <label style="margin:0;">Pr√≥xima revis√£o:</label>
            <input type="date" id="editNextReviewDate">
        </div>

    <div class="tag-selector">
      <label class="tag-selector-label">Etiquetas:</label>
      <div class="tag-search-section">
        <input type="text" class="tag-search-input" id="editTagSearchInput" placeholder="üîç Buscar tags existentes...">
        <div class="tag-search-info">Total: <span id="editTagCountInfo">0</span> | Exibindo: <span id="editTagDisplayInfo">0</span></div>
      </div>
      <div class="existing-tags" id="editExistingTags"></div>
      <div class="new-tag-section">
        <label class="new-tag-section-label">Adicionar Nova Etiqueta:</label>
        <input type="text" class="new-tag-input" id="editNewTagInput" placeholder="#Python, #Recurs√£o, etc...">
        <div class="new-tag-hint">Pressione ENTER para adicionar</div>
      </div>
      <div class="selected-tags-display" id="editSelectedTagsDisplay"></div>
    </div>
    <input type="hidden" id="editTags" value="">

    <label>Alternativas (opcional):</label>
    <div id="editAlternativesContainer"></div>
    <button type="button" id="editAddAlternative">Adicionar Alternativa</button>

    <label for="editCorrectAlt">Alternativa Correta:</label>
    <select id="editCorrectAlt">
      <option value="">Selecione</option>
    </select>

    <button id="saveEdit">Salvar Edi√ß√£o</button>
  </div>
</div>

<!-- Modal for new exercise -->
<div id="newModal" class="modal">
  <div class="modal-content">
    <span class="close" id="closeNewModal">&times;</span>
    <h2>Novo Exerc√≠cio</h2>
    <form id="exerciseForm">
      <label for="title">T√≠tulo do Exerc√≠cio:</label>
      <input type="text" id="title">

      <label for="difficulty">Dificuldade:</label>
      <select id="difficulty" required>
        <option value="">Selecione</option>
        <option value="easy">F√°cil</option>
        <option value="medium">M√©dio</option>
        <option value="hard">Dif√≠cil</option>
      </select>

      <label for="category">Categoria:</label>
      <select id="category" required>
        <option value="">Selecione</option>
                <option value="Produ√ß√£o Textual">Produ√ß√£o Textual</option>
                <option value="Gram√°tica Pura">Gram√°tica Pura</option>
                <option value="Preparat√≥rio TOEFL">Preparat√≥rio TOEFL</option>
      </select>

      <label for="image">Upload de Fotos (opcional - m√∫ltiplas imagens permitidas, ou cole com Ctrl+V):</label>
      <input type="file" id="image" accept="image/*" multiple>
      
      <div id="multiImagePreview" style="display:none; margin-top: 15px;">
        <h3>Imagens Selecionadas:</h3>
        <div id="imagesList" style="border: 1px solid #ddd; border-radius: 8px; padding: 10px; max-height: 300px; overflow-y: auto;"></div>
        <button type="button" id="clearImagesBtn" style="margin-top: 10px;">Limpar Imagens</button>
      </div>

      <label for="exerciseText">Texto do Exerc√≠cio (opcional, use HTML para hyperlinks, [[]] para intralink):</label>
      <textarea id="exerciseText" rows="5"></textarea>

      <label for="answerImage">Imagem da Resposta (opcional):</label>
      <input type="file" id="answerImage" accept="image/*">
    <label for="audio">√Åudio do Exerc√≠cio (opcional):</label>
    <input type="file" id="audio" accept="audio/*">
    <label for="answerAudio">√Åudio da Resposta (opcional):</label>
    <input type="file" id="answerAudio" accept="audio/*">

    <label style="margin-top:8px;"><input type="checkbox" id="reviewFlag"> Marcar para revis√£o</label>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
            <label style="margin:0;">Recorr√™ncia:</label>
            <select id="recurrence">
                <option value="">Nenhum</option>
                <option value="daily">Diariamente</option>
                <option value="weekly">Semanalmente</option>
                <option value="monthly">Mensalmente</option>
            </select>
            <label style="margin:0;">Pr√≥xima revis√£o:</label>
            <input type="date" id="nextReviewDate">
        </div>

      <div class="tag-selector">
        <label class="tag-selector-label">Etiquetas:</label>
        <div class="tag-search-section">
          <input type="text" class="tag-search-input" id="tagSearchInput" placeholder="üîç Buscar tags existentes...">
          <div class="tag-search-info">Total: <span id="tagCountInfo">0</span> | Exibindo: <span id="tagDisplayInfo">0</span></div>
        </div>
        <div class="existing-tags" id="existingTags"></div>
        <div class="new-tag-section">
          <label class="new-tag-section-label">Adicionar Nova Etiqueta:</label>
          <input type="text" class="new-tag-input" id="newTagInput" placeholder="#Python, #Recurs√£o, etc...">
          <div class="new-tag-hint">Pressione ENTER para adicionar</div>
        </div>
        <div class="selected-tags-display" id="selectedTagsDisplay"></div>
      </div>
      <input type="hidden" id="tags" value="">

      <label>Alternativas (opcional):</label>
      <div id="alternativesContainer"></div>
      <button type="button" id="addAlternative">Adicionar Alternativa</button>

      <label for="correctAlt">Alternativa Correta:</label>
      <select id="correctAlt">
        <option value="">Selecione</option>
      </select>

      <button type="submit" id="submitBtn">Salvar Exerc√≠cio(s)</button>
      
      <!-- Progress bar for multiple uploads -->
      <div id="uploadProgress" style="display:none; margin-top: 15px;">
        <div style="background: #f0f0f0; border-radius: 5px; overflow: hidden; height: 25px;">
          <div id="progressBar" style="background: linear-gradient(90deg, #d32f2f, #b71c1c); height: 100%; width: 0%; transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-size: 12px; font-weight: bold;">0%</div>
        </div>
        <p id="uploadStatus" style="text-align: center; font-size: 14px; margin-top: 10px; color: #666;">Carregando...</p>
      </div>
    </form>
  </div>
</div>

<!-- Modal for stats -->
<div id="statsModal" class="modal">
  <div class="modal-content">
    <span class="close" id="closeStatsModal">&times;</span>
    <h2>Estat√≠sticas Di√°rias</h2>
    <label for="statsDate">Data:</label>
    <input type="date" id="statsDate">

    <label for="statsDone">Quest√µes Feitas:</label>
    <input type="number" id="statsDone" min="0">

    <label for="statsCorrect">Acertos:</label>
    <input type="number" id="statsCorrect" min="0">

    <label for="statsWrong">Erros:</label>
    <input type="number" id="statsWrong" min="0">

    <label for="statsGoal">Meta:</label>
    <input type="number" id="statsGoal" min="0">

    <button id="saveStats">Salvar Estat√≠sticas</button>
  </div>
</div>

<!-- Modal for tags -->
<div id="tagsModal" class="modal">
    <div class="modal-content">
        <span class="close" id="closeTagsModal">&times;</span>
        <h2>Etiquetas</h2>
        <div style="margin-top:10px; margin-bottom:10px;">
            <button id="clearTagFilter" style="margin-bottom:8px;">Mostrar todas</button>
        </div>
        <div id="tagsList" style="display:flex; flex-wrap:wrap; gap:8px;"></div>
    </div>
</div>

    <!-- Modal for flashcards management -->
    <div id="flashcardsModal" class="modal">
        <div class="modal-content">
            <span class="close" id="closeFlashcardsModal">&times;</span>
            <h2>Flashcards</h2>
            <div style="display:flex; gap:12px;">
                <button id="newBatchBtn" class="btn">Criar Novo Lote</button>
                <select id="batchSelect"><option value="">-- Selecionar Lote --</option></select>
                <button id="editBatchBtn" class="btn secondary">Editar</button>
                <button id="deleteBatchBtn" class="btn secondary">Excluir</button>
                <button id="studyBatchBtn" class="btn">Estudar</button>
            </div>
            <div id="flashcardsManage" style="margin-top:12px;"></div>
        </div>
    </div>

    <!-- Modal for review list -->
    <div id="reviewModal" class="modal">
        <div class="modal-content">
            <span class="close" id="closeReviewModal">&times;</span>
            <h2>Revis√µes Pendentes</h2>
            <div id="reviewList" style="max-height:400px; overflow:auto; margin-top:8px;"></div>
        </div>
    </div>

    <!-- Modal for creating a new batch -->
    <div id="newBatchModal" class="modal">
        <div class="modal-content">
            <span class="close" id="closeNewBatchModal">&times;</span>
            <h2>Novo Lote de Flashcards</h2>
            <label>Nome do Lote:</label>
            <input type="text" id="batchName" placeholder="Vocabul√°rio - Burgers">
            <div id="cardsContainer" style="margin-top:10px;"></div>
            <button id="addCardBtn" class="btn secondary">Adicionar Card</button>
            <div style="margin-top:10px;">
                <button id="saveBatchBtn" class="btn">Salvar Lote</button>
            </div>
        </div>
    </div>

    <!-- Modal for studying -->
    <div id="studyModal" class="modal">
        <div class="modal-content">
            <span class="close" id="closeStudyModal">&times;</span>
            <h2 id="studyTitle">Estudar</h2>
            <div id="studyArea" style="text-align:center; margin-top:10px;">
                <div id="cardFront" style="font-size:20px; padding:20px; border:1px solid #ccc; border-radius:8px; min-height:80px;"></div>
                <audio id="cardAudio" controls style="display:none; margin-top:8px; width:100%;"></audio>
                <div id="cardBack" style="display:none; margin-top:12px; font-size:18px; color:#333;"></div>
                <div style="margin-top:12px; display:flex; gap:8px; justify-content:center;">
                    <button id="flipCardBtn" class="btn">Mostrar/Esconder Resposta</button>
                    <button id="prevCardBtn" class="btn secondary">Anterior</button>
                    <button id="nextCardBtn" class="btn">Pr√≥ximo</button>
                    <button id="shuffleCardsBtn" class="btn secondary">Embaralhar</button>
                </div>
            </div>
        </div>
    </div>

<!-- Modal for storage -->
<div id="storageModal" class="modal">
    <div class="modal-content">
        <span class="close" id="closeStorageModal">&times;</span>
        <h2>üìä Gerenciador de Storage</h2>
        <div id="storageInfo" style="margin: 20px 0; padding: 15px; background: #f0f0f0; border-radius: 8px;">
            <p><strong>Espa√ßo Usado:</strong> <span id="usedStorage">Calculando...</span></p>
            <p><strong>Espa√ßo Dispon√≠vel:</strong> ~5-10 MB (localStorage)</p>
            <p><strong>Total de Exerc√≠cios:</strong> <span id="totalExercises">0</span></p>
            <p><strong>Tamanho M√©dio por Exerc√≠cio:</strong> <span id="avgSize">0</span> KB</p>
        </div>
        
        <h3>Limpeza Manual</h3>
        <div style="margin: 15px 0;">
            <label style="display: block; margin-bottom: 10px;">
                <input type="checkbox" id="clearExercises"> Limpar todos os exerc√≠cios
            </label>
            <label style="display: block; margin-bottom: 10px;">
                <input type="checkbox" id="clearStats"> Limpar estat√≠sticas
            </label>
            <label style="display: block; margin-bottom: 10px;">
                <input type="checkbox" id="clearSimulado"> Limpar hist√≥rico de simulados
            </label>
            <label style="display: block; margin-bottom: 10px;">
                <input type="checkbox" id="clearTimers"> Limpar timers
            </label>
        </div>
        
        <div style="margin-top: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px; margin-bottom: 15px;">
            <strong>üíæ IndexedDB Ativado</strong>
            <p style="margin: 8px 0; font-size: 14px;">
                Seu armazenamento agora usa <strong>IndexedDB (50MB+)</strong> como principal, com localStorage como backup autom√°tico.
            </p>
        </div>

        <div style="margin-top: 20px; padding: 15px; background: #f3e5f5; border-radius: 8px; margin-bottom: 15px;">
            <strong>‚òÅÔ∏è Dropbox Sync</strong>
            <p style="margin: 8px 0; font-size: 14px;" id="dropboxStatus">N√£o conectado ao Dropbox</p>
            <div style="margin: 8px 6px; font-size: 12px; color: #666;">
                ‚ÑπÔ∏è <strong>Como funciona:</strong> Quando conectado, clique em "‚¨ÜÔ∏è Sincronizar" para fazer upload de <strong>TODOS</strong> os seus dados de uma vez. Isso cria um backup de tudo em um √∫nico arquivo no Dropbox. Opera√ß√µes locais (adicionar/editar) continuam funcionando normalmente em IndexedDB/localStorage sem afet√°-lo.
            </div>
            <div id="dropboxControls" style="margin-top: 10px;">
                <button id="dropboxLoginBtn" style="background: #d32f2f; color: white; padding: 8px 12px; margin-right: 8px; border: none; border-radius: 5px; cursor: pointer; font-size: 13px;">üîó Conectar Dropbox</button>
                <button id="dropboxSyncBtn" style="background: #d32f2f; color: white; padding: 8px 12px; margin-right: 8px; border: none; border-radius: 5px; cursor: pointer; font-size: 13px; display: none;">‚¨ÜÔ∏è Sincronizar Agora</button>
                <button id="dropboxRestoreBtn" style="background: #00b894; color: white; padding: 8px 12px; margin-right: 8px; border: none; border-radius: 5px; cursor: pointer; font-size: 13px; display: none;">‚¨áÔ∏è Restaurar</button>
                <button id="dropboxLogoutBtn" style="background: #ff6b6b; color: white; padding: 8px 12px; border: none; border-radius: 5px; cursor: pointer; font-size: 13px; display: none;">üö™ Desconectar</button>
            </div>
        </div>
        
        <div style="margin-top: 20px;">
            <button id="calculateStorageBtn" style="background: #d32f2f; color: white; padding: 10px 15px; margin-right: 10px; border: none; border-radius: 5px; cursor: pointer;">Recalcular</button>
            <button id="cleanupStorageBtn" style="background: #ff5722; color: white; padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer;">üóëÔ∏è Limpar Selecionados</button>
        </div>
    </div>
</div>

<!-- Modal for new simulado -->
<div id="simuladoModal" class="modal">
  <div class="modal-content">
    <span class="close" id="closeSimuladoModal">&times;</span>
    <h2>Criar Novo Simulado</h2>
    <form id="simuladoForm">
      <fieldset>
        <legend>Configura√ß√µes Gerais</legend>
        <label for="simuladoTime">Tempo (minutos):</label>
        <input type="number" id="simuladoTime" min="1" value="30" required>
        
        <label for="numQuestions">N√∫mero de Quest√µes:</label>
        <input type="number" id="numQuestions" min="1" value="10" required>
      </fieldset>
      
      <fieldset>
        <legend>Filtros (selecione os desejados)</legend>
        <div class="filter-group">
          <strong>Dificuldade:</strong>
          <div class="checkbox-group">
            <input type="checkbox" id="difficultyEasy" value="easy">
            <label for="difficultyEasy">F√°cil</label>
            <input type="checkbox" id="difficultyMedium" value="medium">
            <label for="difficultyMedium">M√©dio</label>
            <input type="checkbox" id="difficultyHard" value="hard">
            <label for="difficultyHard">Dif√≠cil</label>
          </div>
        </div>
        <div class="filter-group">
          <strong>Categoria:</strong>
          <div class="checkbox-group">
                        <input type="checkbox" id="categoryProducao" value="Produ√ß√£o Textual">
                        <label for="categoryProducao">Produ√ß√£o Textual</label>
                        <input type="checkbox" id="categoryGramatica" value="Gram√°tica Pura">
                        <label for="categoryGramatica">Gram√°tica Pura</label>
                        <input type="checkbox" id="categoryToefl" value="Preparat√≥rio TOEFL">
                        <label for="categoryToefl">Preparat√≥rio TOEFL</label>
          </div>
        </div>
        <div class="filter-group">
          <label for="simuladoTag">Etiquetas (#, separadas por v√≠rgula, opcional):</label>
          <input type="text" id="simuladoTag" placeholder="#Tag1, #Tag2">
        </div>
                <div class="filter-group">
                    <label for="simuladoStatus">Status do Exerc√≠cio:</label>
                    <select id="simuladoStatus">
                        <option value="all">Todos</option>
                        <option value="done">Conclu√≠dos</option>
                        <option value="not-done">N√£o Conclu√≠dos</option>
                    </select>
                </div>
      </fieldset>
      
      <button type="button" id="startSimulado">Iniciar Simulado</button>
    </form>
  </div>
</div>

<input type="file" id="importFile" accept=".json" style="display:none">

<script>
        // ============================================
        // DROPBOX INTEGRATION
        // ============================================
        const DROPBOX_CLIENT_ID = 'YOUR_CLIENT_ID'; // Ser√° setado pelo usu√°rio
        let dropboxAuth = null;
        let isDropboxConnected = false;

        class DropboxManager {
            constructor() {
                this.isAuthenticated = false;
                this.accessToken = localStorage.getItem('dropbox_token');
                if (this.accessToken) {
                    this.isAuthenticated = true;
                }
            }

            async authenticate() {
                try {
                    const token = prompt('Cole seu Access Token do Dropbox:\n\n(Obt√©m em: https://www.dropbox.com/developers/apps ‚Üí Sua App ‚Üí Generate access token)', '');
                    if (!token || token.trim().length === 0) {
                        alert('‚ùå Token inv√°lido! Verifique se copiou corretamente.');
                        return false;
                    }

                    // Salvar token sem valida√ß√£o (ser√° testado no primeiro sync)
                    this.setAccessToken(token.trim());
                    alert('‚úÖ Token salvo! Clique em "‚¨ÜÔ∏è Sincronizar" para testar.');
                    return true;
                } catch (error) {
                    console.error('Erro ao colar token:', error);
                    alert('‚ùå Erro ao colar token. Tente novamente.');
                    return false;
                }
            }

            setAccessToken(token) {
                this.accessToken = token;
                localStorage.setItem('dropbox_token', token);
                this.isAuthenticated = true;
                updateDropboxStatus();
            }

            logout() {
                this.accessToken = null;
                this.isAuthenticated = false;
                localStorage.removeItem('dropbox_token');
                localStorage.removeItem('dropbox_client_id');
                updateDropboxStatus();
            }

            async uploadToDropbox(data) {
                if (!this.isAuthenticated || !this.accessToken) {
                    alert('Voc√™ precisa conectar ao Dropbox primeiro.');
                    return false;
                }

                try {
                    const fileName = `/ExerciseApp/backup.json`;
                    const jsonString = JSON.stringify(data, null, 2);
                    const blob = new Blob([jsonString]);
                    const size = blob.size;

                    // If small enough, do a single upload (Dropbox limit ~150MB)
                    const SINGLE_UPLOAD_LIMIT = 150 * 1024 * 1024; // 150MB
                    if (size <= SINGLE_UPLOAD_LIMIT) {
                        const response = await fetch('https://content.dropboxapi.com/2/files/upload', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${this.accessToken}`,
                                'Dropbox-API-Arg': JSON.stringify({
                                    path: fileName,
                                    mode: 'overwrite',
                                    mute: false
                                }),
                                'Content-Type': 'application/octet-stream'
                            },
                            body: blob
                        });

                        if (!response.ok) {
                            const errorData = await response.text();
                            console.error('Erro Dropbox:', errorData);
                            if (response.status === 401) {
                                alert('‚ùå Token inv√°lido ou expirado!\n\nGere um novo token em:\nhttps://www.dropbox.com/developers/apps');
                                this.logout();
                                return false;
                            }
                            alert(`‚ùå Erro ${response.status}: ${errorData}`);
                            return false;
                        }

                        const result = await response.json();
                        console.log('Backup enviado para Dropbox:', result);
                        alert('‚úÖ Backup sincronizado com Dropbox com sucesso!');
                        return true;
                    }

                    // For large files, use upload_session (chunked)
                    const CHUNK_SIZE = 8 * 1024 * 1024; // 8MB
                    let offset = 0;

                    // start session with first chunk
                    const firstChunk = blob.slice(0, CHUNK_SIZE);
                    let res = await fetch('https://content.dropboxapi.com/2/files/upload_session/start', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/octet-stream',
                            'Dropbox-API-Arg': JSON.stringify({ close: false })
                        },
                        body: firstChunk
                    });

                    if (!res.ok) {
                        const err = await res.text();
                        console.error('Erro start session:', err);
                        alert('‚ùå Erro ao iniciar upload em sess√£o. ' + err);
                        return false;
                    }

                    const startData = await res.json();
                    const sessionId = startData.session_id;
                    offset += CHUNK_SIZE;

                    // append middle chunks
                    while (offset + CHUNK_SIZE < size) {
                        const chunk = blob.slice(offset, offset + CHUNK_SIZE);
                        const arg = { cursor: { session_id: sessionId, offset: offset }, close: false };
                        const appendRes = await fetch('https://content.dropboxapi.com/2/files/upload_session/append_v2', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${this.accessToken}`,
                                'Content-Type': 'application/octet-stream',
                                'Dropbox-API-Arg': JSON.stringify(arg)
                            },
                            body: chunk
                        });

                        if (!appendRes.ok) {
                            const err = await appendRes.text();
                            console.error('Erro append session:', err);
                            alert('‚ùå Erro ao enviar parte do upload em sess√£o. ' + err);
                            return false;
                        }

                        offset += CHUNK_SIZE;
                    }

                    // finish with last chunk
                    const lastChunk = blob.slice(offset, size);
                    const commit = { path: fileName, mode: 'overwrite', mute: false };
                    const finishArg = { cursor: { session_id: sessionId, offset: offset }, commit };

                    const finishRes = await fetch('https://content.dropboxapi.com/2/files/upload_session/finish', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/octet-stream',
                            'Dropbox-API-Arg': JSON.stringify(finishArg)
                        },
                        body: lastChunk
                    });

                    if (!finishRes.ok) {
                        const err = await finishRes.text();
                        console.error('Erro finish session:', err);
                        alert('‚ùå Erro ao finalizar upload em sess√£o. ' + err);
                        return false;
                    }

                    const finishResult = await finishRes.json();
                    console.log('Upload session finalizado:', finishResult);
                    alert('‚úÖ Backup grande sincronizado com Dropbox com sucesso!');
                    return true;
                } catch (error) {
                    console.error('Erro ao fazer upload para Dropbox:', error);
                    alert('‚ùå Erro de conex√£o. Verifique sua internet ou tente novamente.');
                    return false;
                }
            }

            async downloadFromDropbox() {
                if (!this.isAuthenticated || !this.accessToken) {
                    alert('Voc√™ precisa conectar ao Dropbox primeiro.');
                    return null;
                }

                try {
                    const response = await fetch('https://api.dropboxapi.com/2/files/list_folder', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            path: '/ExerciseApp',
                            recursive: false,
                            include_media_info: false,
                            include_deleted: false,
                            include_has_explicit_shared_members: false,
                            include_mounted_folders: false
                        })
                    });

                    if (!response.ok) {
                        if (response.status === 401) {
                            alert('‚ùå Token inv√°lido ou expirado!');
                            this.logout();
                            return null;
                        }
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const result = await response.json();
                    if (result.entries.length === 0) {
                        alert('Nenhum backup encontrado no Dropbox.');
                        return null;
                    }

                    // Pega o arquivo mais recente
                    const latestFile = result.entries.sort((a, b) => 
                        new Date(b.server_modified) - new Date(a.server_modified)
                    )[0];

                    const fileResponse = await fetch('https://content.dropboxapi.com/2/files/download', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Dropbox-API-Arg': JSON.stringify({
                                path: latestFile.path_display
                            })
                        }
                    });

                    if (!fileResponse.ok) {
                        if (fileResponse.status === 401) {
                            alert('‚ùå Token inv√°lido ou expirado!');
                            this.logout();
                            return null;
                        }
                        throw new Error(`HTTP ${fileResponse.status}`);
                    }

                    const data = await fileResponse.json();
                    console.log('Dados restaurados do Dropbox:', data);
                    alert('‚úÖ Dados restaurados do Dropbox com sucesso!');
                    return data;
                } catch (error) {
                    console.error('Erro ao baixar de Dropbox:', error);
                    alert('‚ùå Erro ao restaurar dados do Dropbox. Verifique sua conex√£o.');
                    return null;
                }
            }
        }

        const dropboxManager = new DropboxManager();

        function updateDropboxStatus() {
            const statusEl = document.getElementById('dropboxStatus');
            const loginBtn = document.getElementById('dropboxLoginBtn');
            const syncBtn = document.getElementById('dropboxSyncBtn');
            const restoreBtn = document.getElementById('dropboxRestoreBtn');
            const logoutBtn = document.getElementById('dropboxLogoutBtn');

            if (dropboxManager.isAuthenticated) {
                statusEl.textContent = '‚úÖ Conectado ao Dropbox';
                statusEl.style.color = 'green';
                loginBtn.style.display = 'none';
                syncBtn.style.display = 'inline-block';
                restoreBtn.style.display = 'inline-block';
                logoutBtn.style.display = 'inline-block';
            } else {
                statusEl.textContent = '‚ùå N√£o conectado ao Dropbox';
                statusEl.style.color = 'red';
                loginBtn.style.display = 'inline-block';
                syncBtn.style.display = 'none';
                restoreBtn.style.display = 'none';
                logoutBtn.style.display = 'none';
            }
        }

        // ============================================
        // IndexedDB Setup - Primary storage (50MB+)
        let db = null;
        const DB_NAME = 'ExerciseApp';
        const DB_VERSION = 1;
        const STORES = {
            exercises: 'exercises',
            stats: 'stats',
            timers: 'timers',
            simuladoHistory: 'simuladoHistory'
        };
        
        // Initialize IndexedDB
        function initIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => {
                    console.error('IndexedDB error:', request.error);
                    reject(request.error);
                };
                
                request.onsuccess = () => {
                    db = request.result;
                    console.log('IndexedDB initialized successfully');
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Create object stores if they don't exist
                    Object.values(STORES).forEach(storeName => {
                        if (!db.objectStoreNames.contains(storeName)) {
                            db.createObjectStore(storeName, { keyPath: 'id', autoIncrement: true });
                        }
                    });
                };
            });
        }
        
        // Save to IndexedDB
        function saveToIndexedDB(storeName, key, data) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('IndexedDB not initialized');
                    return;
                }
                
                try {
                    const transaction = db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put({ id: key, data: data });
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        // Load from IndexedDB
        function loadFromIndexedDB(storeName, key) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('IndexedDB not initialized');
                    return;
                }
                
                try {
                    const transaction = db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(key);
                    
                    request.onsuccess = () => {
                        resolve(request.result ? request.result.data : null);
                    };
                    request.onerror = () => reject(request.error);
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        // Get all items from a store
        function getAllFromIndexedDB(storeName) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('IndexedDB not initialized');
                    return;
                }
                
                try {
                    const transaction = db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        const items = request.result.map(item => item.data);
                        resolve(items);
                    };
                    request.onerror = () => reject(request.error);
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        // Clear a store
        function clearIndexedDBStore(storeName) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject('IndexedDB not initialized');
                    return;
                }
                
                try {
                    const transaction = db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.clear();
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        // Load data - tries IndexedDB first, falls back to localStorage
        async function loadData() {
            try {
                const exercisesFromDB = await loadFromIndexedDB(STORES.exercises, 'exercises');
                const statsFromDB = await loadFromIndexedDB(STORES.stats, 'stats');
                const timersFromDB = await loadFromIndexedDB(STORES.timers, 'timers');
                const simuladoFromDB = await loadFromIndexedDB(STORES.simuladoHistory, 'simuladoHistory');
                
                return {
                    exercises: exercisesFromDB || JSON.parse(localStorage.getItem('exercises')) || [],
                    stats: statsFromDB || JSON.parse(localStorage.getItem('stats')) || {},
                    timers: timersFromDB || JSON.parse(localStorage.getItem('timers')) || {},
                    simuladoHistory: simuladoFromDB || JSON.parse(localStorage.getItem('simuladoHistory')) || []
                };
            } catch (error) {
                console.log('Usando localStorage como fallback:', error);
                return {
                    exercises: JSON.parse(localStorage.getItem('exercises')) || [],
                    stats: JSON.parse(localStorage.getItem('stats')) || {},
                    timers: JSON.parse(localStorage.getItem('timers')) || {},
                    simuladoHistory: JSON.parse(localStorage.getItem('simuladoHistory')) || []
                };
            }
        }
        
        let exercises = [];
        let stats = {};
        let timers = {};
        let simuladoHistory = [];
        let pendingSync = false;  // Flag para sincroniza√ß√£o pendente com Dropbox
        let isSyncing = false;    // Flag para evitar m√∫ltiplas sincroniza√ß√µes simult√¢neas
        
        // Initialize on load
        initIndexedDB().then(async () => {
            // Tentar carregar dados do Dropbox automaticamente
            const dropboxData = await dropboxManager.downloadFromDropbox().catch(() => null);
            
            if (dropboxData) {
                // Dados carregados com sucesso do Dropbox
                exercises = dropboxData.exercises || [];
                stats = dropboxData.stats || {};
                timers = dropboxData.timers || {};
                simuladoHistory = dropboxData.simuladoHistory || [];
                console.log('‚úÖ Dados carregados do Dropbox');
            } else {
                // Fallback: carregar dados locais (IndexedDB/localStorage)
                const data = await loadData();
                exercises = data.exercises;
                stats = data.stats;
                timers = data.timers;
                simuladoHistory = data.simuladoHistory;
                console.log('üì± Usando dados locais (Dropbox indispon√≠vel ou vazio)');
            }
            
            // Initialize Dropbox status
            updateDropboxStatus();
            
            // Process exercises
            exercises.forEach(ex => {
                if (!ex.createdAt) ex.createdAt = ex.updatedAt || new Date().toISOString();
                    if (!ex.category) ex.category = 'Produ√ß√£o Textual';
                if (ex.alternatives && ex.alternatives.length > 0 && ex.correctIndex === undefined) {
                    ex.correctIndex = 0;
                }
                if (!ex.done) ex.done = false;
                if (!ex.favorite) ex.favorite = false;
                if (!ex.status) {
                    ex.status = ex.done ? 'done' : 'not-done';
                }
            });
            
            console.log('Dados carregados com sucesso!');
            showExercises();
        }).catch(error => {
            console.error('Erro ao inicializar IndexedDB, usando localStorage:', error);
            exercises = JSON.parse(localStorage.getItem('exercises')) || [];
            stats = JSON.parse(localStorage.getItem('stats')) || {};
            timers = JSON.parse(localStorage.getItem('timers')) || {};
            simuladoHistory = JSON.parse(localStorage.getItem('simuladoHistory')) || [];
            
            exercises.forEach(ex => {
                if (!ex.createdAt) ex.createdAt = ex.updatedAt || new Date().toISOString();
                if (!ex.category) ex.category = 'Produ√ß√£o Textual';
                if (ex.alternatives && ex.alternatives.length > 0 && ex.correctIndex === undefined) {
                    ex.correctIndex = 0;
                }
                if (!ex.done) ex.done = false;
                if (!ex.favorite) ex.favorite = false;
                if (!ex.status) {
                    ex.status = ex.done ? 'done' : 'not-done';
                }
            });
            
            showExercises();
        });
        
        // Helper function - salvamento autom√°tico desabilitado
        // O salvamento APENAS ocorre quando o usu√°rio clica "Sincronizar" (upload para Dropbox)
        async function saveToStorage(key, data) {
            // N√£o faz nada - todo salvamento √© manual via Dropbox sync
            console.log(`üìù Dados em mem√≥ria (${key}) - ser√° salvo no Dropbox ao sincronizar`);
        }
        
        // Legacy function for compatibility
        function saveToLocalStorage(key, data) {
            return saveToStorage(key, data);
        }

        let currentAnnotationIndex = null;
        let editingIndex = null;
        let currentCategory = 'Todos';
        let searchTerm = '';
        let sortOrder = 'recent';
        let currentStatus = 'all';
        let currentView = 'exercises';
        let activeTimers = {};
        let currentPage = 1;
        let pageSize = 10;
        let currentRandomIndex = 0;
        let randomExercises = [];
        let isRandomMode = false;

        const randomModeBtn = document.getElementById('randomModeBtn');
        const flashcardsBtn = document.getElementById('flashcardsBtn');
        const reviewBtn = document.getElementById('reviewBtn');
        const reviewModal = document.getElementById('reviewModal');
        const closeReviewModal = document.getElementById('closeReviewModal');
        const reviewList = document.getElementById('reviewList');
        let pendingAudioResume = null;
        const flashcardsModal = document.getElementById('flashcardsModal');
        const closeFlashcardsModal = document.getElementById('closeFlashcardsModal');
        const newBatchModal = document.getElementById('newBatchModal');
        const closeNewBatchModal = document.getElementById('closeNewBatchModal');
        const studyModal = document.getElementById('studyModal');
        const closeStudyModal = document.getElementById('closeStudyModal');

        // Flashcards data
        let flashcardBatches = JSON.parse(localStorage.getItem('flashcardBatches') || '[]');

        function saveFlashcardBatches() {
            localStorage.setItem('flashcardBatches', JSON.stringify(flashcardBatches));
            try { if (typeof updateReviewIndicator === 'function') updateReviewIndicator(); } catch(e) {}
        }

        function refreshBatchSelect() {
            const sel = document.getElementById('batchSelect');
            sel.innerHTML = '<option value="">-- Selecionar Lote --</option>';
            flashcardBatches.forEach(b => {
                const opt = document.createElement('option');
                opt.value = b.id;
                opt.textContent = b.name + ' (' + (b.cards ? b.cards.length : 0) + ')';
                sel.appendChild(opt);
            });
        }

        // Create UI card row for new-batch modal
        function createCardRow(card = {front:'', back:'', audioFront:null, audioBack:null, review:false}) {
            const div = document.createElement('div');
            div.className = 'card-row';
            div.style.border = '1px solid #ddd';
            div.style.padding = '8px';
            div.style.marginBottom = '8px';
            div.innerHTML = `
                <label>Frente:</label>
                <input class="card-front" type="text" value="${(card.front||'').replace(/"/g,'&quot;')}">
                <label>Verso:</label>
                <input class="card-back" type="text" value="${(card.back||'').replace(/"/g,'&quot;')}">
                <label>√Åudio Frente:</label>
                <input class="card-front-audio" type="file" accept="audio/*">
                <label>√Åudio Verso:</label>
                <input class="card-back-audio" type="file" accept="audio/*">
                <label style="margin-left:8px;"><input type="checkbox" class="card-review-flag" ${card.review ? 'checked' : ''}> Revisar?</label>
                <button type="button" class="remove-card-btn">Remover</button>
            `;
            div.querySelector('.remove-card-btn').addEventListener('click', () => div.remove());
            // If card has existing audio previews, show small players
            if (card.audioFront) {
                const p = document.createElement('div');
                p.innerHTML = `<audio controls src="${card.audioFront}" style="display:block; margin-top:6px; width:100%;"></audio>`;
                div.appendChild(p);
            }
            if (card.audioBack) {
                const p2 = document.createElement('div');
                p2.innerHTML = `<audio controls src="${card.audioBack}" style="display:block; margin-top:6px; width:100%;"></audio>`;
                div.appendChild(p2);
            }
            return div;
        }

        // Wire flashcards UI events
        flashcardsBtn.addEventListener('click', () => { refreshBatchSelect(); openModal(flashcardsModal); });
        closeFlashcardsModal.addEventListener('click', () => closeModalWindow(flashcardsModal));
        // Wire review UI events ‚Äî open the review sequence in the random box
        reviewBtn.addEventListener('click', () => { startReviewMode(); });
        closeReviewModal.addEventListener('click', () => closeModalWindow(reviewModal));

        function updateReviewIndicator() {
            const now = new Date();
            const pendingExercises = exercises.filter(e => {
                if (e.review) return true;
                if (e.nextReview) {
                    try { return new Date(e.nextReview) <= now; } catch(e) { return false; }
                }
                return false;
            }).length;
            let pendingFlashcards = 0;
            for (const b of flashcardBatches) {
                if (!b.cards) continue;
                pendingFlashcards += b.cards.filter(c => {
                    if (c.review) return true;
                    if (c.nextReview) {
                        try { return new Date(c.nextReview) <= now; } catch(e) { return false; }
                    }
                    return false;
                }).length;
            }
            const pending = pendingExercises + pendingFlashcards;
            const badge = document.getElementById('reviewCount');
            if (badge) badge.textContent = pending;
            if (reviewBtn) {
                reviewBtn.classList.toggle('pending', pending > 0);
            }
        }

        function renderReviewList() {
            reviewList.innerHTML = '';
            const pendingExercises = exercises.filter(e => e.review) || [];
            // group pending flashcards by batch
            const pendingFlashcards = {};
            const now = new Date();
            for (const b of flashcardBatches) {
                (b.cards || []).forEach((c, i) => {
                    const due = c && (c.review || (c.nextReview && (() => { try { return new Date(c.nextReview) <= now; } catch(e) { return false; } })()));
                    if (due) {
                        if (!pendingFlashcards[b.id]) pendingFlashcards[b.id] = { batch: b, indices: [] };
                        pendingFlashcards[b.id].indices.push(i);
                    }
                });
            }
            if (pendingExercises.length === 0 && Object.keys(pendingFlashcards).length === 0) {
                reviewList.innerHTML = '<p>Nenhuma revis√£o pendente.</p>';
                return;
            }
            const topBar = document.createElement('div');
            topBar.style.marginBottom = '8px';
            const reviewAllBtn = document.createElement('button');
            reviewAllBtn.textContent = 'Revisar tudo';
            reviewAllBtn.addEventListener('click', () => { closeModalWindow(reviewModal); startReviewMode(); });
            topBar.appendChild(reviewAllBtn);
            reviewList.appendChild(topBar);

            pendingExercises.forEach(ex => {
                const div = document.createElement('div');
                div.style.border = '1px solid #ddd';
                div.style.padding = '8px';
                div.style.marginBottom = '8px';
                const excerpt = (ex.text || '').slice(0, 160).replace(/</g,'&lt;').replace(/>/g,'&gt;');
                div.innerHTML = `<strong>${(ex.title||'Sem t√≠tulo')}</strong><div style="margin-top:6px;">${excerpt}${(ex.text && ex.text.length>160? '...' : '')}</div>`;
                if (ex.audio) {
                    const a = document.createElement('div');
                    a.innerHTML = `<audio controls src="${ex.audio}" style="display:block; margin-top:6px; width:100%;"></audio>`;
                    div.appendChild(a);
                }
                const actions = document.createElement('div');
                actions.style.marginTop = '6px';
                const openBtn = document.createElement('button');
                openBtn.textContent = 'Abrir';
                openBtn.addEventListener('click', () => { closeModalWindow(reviewModal); startReviewMode(ex.id); });
                const agendarBtn = document.createElement('button');
                agendarBtn.textContent = 'Agendar';
                agendarBtn.style.marginLeft = '8px';
                agendarBtn.addEventListener('click', () => {
                    const choice = prompt('Digite: 1w (1 semana), 1m (1 m√™s) ou data YYYY-MM-DD para agendar:');
                    if (!choice) return;
                    let next = null; let recurring = null;
                    if (choice === '1w') { const d = new Date(); d.setDate(d.getDate()+7); next = d.toISOString(); recurring = confirm('Repetir semanalmente? OK=Sim, Cancel=N√£o') ? 'weekly' : null; }
                    else if (choice === '1m') { const d = new Date(); d.setMonth(d.getMonth()+1); next = d.toISOString(); recurring = confirm('Repetir mensalmente? OK=Sim, Cancel=N√£o') ? 'monthly' : null; }
                    else {
                        const parsed = new Date(choice);
                        if (isNaN(parsed)) { alert('Data inv√°lida'); return; }
                        next = parsed.toISOString(); recurring = confirm('Repetir? OK=Sim, Cancel=N√£o') ? 'custom' : null;
                    }
                    const idx = exercises.findIndex(x => x.id === ex.id);
                    if (idx !== -1) {
                        exercises[idx].review = false;
                        exercises[idx].nextReview = next;
                        exercises[idx].recurring = recurring;
                        exercises[idx].updatedAt = new Date().toISOString();
                        localStorage.setItem('exercises', JSON.stringify(exercises));
                        renderReviewList();
                        displayExercises();
                        updateReviewIndicator();
                    }
                });
                // Recurrence quick button (Diariamente/Semanalmente/Mensalmente/Nenhum)
                const recurBtn = document.createElement('button');
                recurBtn.textContent = 'Recorr√™ncia ‚ñæ';
                recurBtn.style.marginLeft = '8px';
                recurBtn.addEventListener('click', () => {
                    const opt = prompt('Escolha: none, daily, weekly, monthly (ex: daily)');
                    if (!opt) return;
                    let next = null; let recurring = null;
                    const today = new Date();
                    if (opt === 'none' || opt === 'nenhum') { recurring = null; next = null; }
                    else if (opt === 'daily' || opt === 'diariamente') { recurring = 'daily'; const d = new Date(today); d.setDate(d.getDate()+1); next = d.toISOString(); }
                    else if (opt === 'weekly' || opt === 'semanalmente') { recurring = 'weekly'; const d = new Date(today); d.setDate(d.getDate()+7); next = d.toISOString(); }
                    else if (opt === 'monthly' || opt === 'mensalmente') { recurring = 'monthly'; const d = new Date(today); d.setMonth(d.getMonth()+1); next = d.toISOString(); }
                    else { alert('Op√ß√£o desconhecida'); return; }
                    const idx = exercises.findIndex(x => x.id === ex.id);
                    if (idx !== -1) {
                        exercises[idx].recurring = recurring;
                        exercises[idx].nextReview = next;
                        exercises[idx].updatedAt = new Date().toISOString();
                        localStorage.setItem('exercises', JSON.stringify(exercises));
                        renderReviewList();
                        displayExercises();
                        updateReviewIndicator();
                    }
                });
                // Show current recurrence pill if present
                if (ex.recurring) {
                    const pill = document.createElement('span');
                    pill.className = 'recurrence-pill';
                    pill.style.marginLeft = '8px';
                    pill.style.padding = '4px 8px';
                    pill.style.background = '#efefef';
                    pill.style.borderRadius = '12px';
                    pill.style.display = 'inline-flex';
                    pill.style.alignItems = 'center';
                    pill.textContent = ex.recurring === 'daily' ? 'Diariamente' : ex.recurring === 'weekly' ? 'Semanalmente' : ex.recurring === 'monthly' ? 'Mensalmente' : 'Recorrente';
                    const clearX = document.createElement('button');
                    clearX.textContent = '‚úï';
                    clearX.style.marginLeft = '8px';
                    clearX.style.border = 'none';
                    clearX.style.background = 'transparent';
                    clearX.addEventListener('click', () => {
                        const idx = exercises.findIndex(x => x.id === ex.id);
                        if (idx !== -1) {
                            exercises[idx].recurring = null;
                            exercises[idx].nextReview = null;
                            exercises[idx].updatedAt = new Date().toISOString();
                            localStorage.setItem('exercises', JSON.stringify(exercises));
                            renderReviewList();
                            displayExercises();
                            updateReviewIndicator();
                        }
                    });
                    pill.appendChild(clearX);
                    actions.appendChild(pill);
                }
                actions.appendChild(openBtn);
                actions.appendChild(agendarBtn);
                actions.appendChild(recurBtn);
                div.appendChild(actions);
                reviewList.appendChild(div);
            });

            // render one entry per batch
            Object.keys(pendingFlashcards).forEach(batchId => {
                const entry = pendingFlashcards[batchId];
                const b = entry.batch;
                const indices = entry.indices;
                const firstCard = b.cards[indices[0]];
                const div = document.createElement('div');
                div.style.border = '1px solid #ddd';
                div.style.padding = '8px';
                div.style.marginBottom = '8px';
                div.innerHTML = `<strong>Flashcards ‚Äî ${b.name} (${indices.length})</strong><div style="margin-top:6px;">${(firstCard && firstCard.front||'').replace(/</g,'&lt;')}</div>`;
                if (firstCard && firstCard.audioFront) {
                    const a = document.createElement('div');
                    a.innerHTML = `<audio controls src="${firstCard.audioFront}" style="display:block; margin-top:6px; width:100%;"></audio>`;
                    div.appendChild(a);
                }
                const actions = document.createElement('div');
                actions.style.marginTop = '6px';
                actions.style.display = 'flex';
                actions.style.justifyContent = 'flex-end';
                const reviewBtnSingle = document.createElement('button');
                reviewBtnSingle.textContent = 'Revisar';
                reviewBtnSingle.style.background = '#d32f2f';
                reviewBtnSingle.style.color = 'white';
                reviewBtnSingle.addEventListener('click', () => {
                    // If there's a preview audio in this entry, capture its state to resume in the review box
                    const aud = div.querySelector('audio');
                    if (aud) {
                        pendingAudioResume = { src: aud.src, time: aud.currentTime, playing: !aud.paused };
                    }
                    closeModalWindow(reviewModal);
                    startReviewMode('batch-' + b.id);
                });
                const agendarBatchBtn = document.createElement('button');
                agendarBatchBtn.textContent = 'Agendar';
                agendarBatchBtn.style.marginLeft = '8px';
                agendarBatchBtn.addEventListener('click', () => {
                    const choice = prompt('Digite: 1w (1 semana), 1m (1 m√™s) ou data YYYY-MM-DD para agendar o lote:');
                    if (!choice) return;
                    let next = null; let recurring = null;
                    if (choice === '1w') { const d = new Date(); d.setDate(d.getDate()+7); next = d.toISOString(); recurring = confirm('Repetir semanalmente? OK=Sim, Cancel=N√£o') ? 'weekly' : null; }
                    else if (choice === '1m') { const d = new Date(); d.setMonth(d.getMonth()+1); next = d.toISOString(); recurring = confirm('Repetir mensalmente? OK=Sim, Cancel=N√£o') ? 'monthly' : null; }
                    else {
                        const parsed = new Date(choice);
                        if (isNaN(parsed)) { alert('Data inv√°lida'); return; }
                        next = parsed.toISOString(); recurring = confirm('Repetir? OK=Sim, Cancel=N√£o') ? 'custom' : null;
                    }
                    const bidx = flashcardBatches.findIndex(bb => bb.id === b.id);
                    if (bidx !== -1) {
                        (indices || []).forEach(ci => { if (flashcardBatches[bidx].cards && flashcardBatches[bidx].cards[ci]) { flashcardBatches[bidx].cards[ci].review = false; flashcardBatches[bidx].cards[ci].nextReview = next; flashcardBatches[bidx].cards[ci].recurring = recurring; } });
                        saveFlashcardBatches();
                        renderReviewList();
                        updateReviewIndicator();
                    }
                });
                // Recurrence quick button for batch
                const recurBatchBtn = document.createElement('button');
                recurBatchBtn.textContent = 'Recorr√™ncia ‚ñæ';
                recurBatchBtn.style.marginLeft = '8px';
                recurBatchBtn.addEventListener('click', () => {
                    const opt = prompt('Escolha: none, daily, weekly, monthly (ex: daily) para o lote');
                    if (!opt) return;
                    let next = null; let recurring = null;
                    const today = new Date();
                    if (opt === 'none' || opt === 'nenhum') { recurring = null; next = null; }
                    else if (opt === 'daily' || opt === 'diariamente') { recurring = 'daily'; const d = new Date(today); d.setDate(d.getDate()+1); next = d.toISOString(); }
                    else if (opt === 'weekly' || opt === 'semanalmente') { recurring = 'weekly'; const d = new Date(today); d.setDate(d.getDate()+7); next = d.toISOString(); }
                    else if (opt === 'monthly' || opt === 'mensalmente') { recurring = 'monthly'; const d = new Date(today); d.setMonth(d.getMonth()+1); next = d.toISOString(); }
                    else { alert('Op√ß√£o desconhecida'); return; }
                    const bidx = flashcardBatches.findIndex(bb => bb.id === b.id);
                    if (bidx !== -1) {
                        (indices || []).forEach(ci => { if (flashcardBatches[bidx].cards && flashcardBatches[bidx].cards[ci]) { flashcardBatches[bidx].cards[ci].recurring = recurring; flashcardBatches[bidx].cards[ci].nextReview = next; flashcardBatches[bidx].cards[ci].review = false; } });
                        saveFlashcardBatches();
                        renderReviewList();
                        updateReviewIndicator();
                    }
                });
                // Show common recurrence pill for batch if all same
                const batchRecValues = (indices || []).map(ci => (b.cards && b.cards[ci] && b.cards[ci].recurring) || null).filter(v => v !== null);
                let commonRec = null;
                if (batchRecValues.length > 0) {
                    const allSame = batchRecValues.every(v => v === batchRecValues[0]);
                    if (allSame) commonRec = batchRecValues[0];
                }
                if (commonRec) {
                    const pill = document.createElement('span');
                    pill.className = 'recurrence-pill';
                    pill.style.marginLeft = '8px';
                    pill.style.padding = '4px 8px';
                    pill.style.background = '#efefef';
                    pill.style.borderRadius = '12px';
                    pill.style.display = 'inline-flex';
                    pill.style.alignItems = 'center';
                    pill.textContent = commonRec === 'daily' ? 'Diariamente' : commonRec === 'weekly' ? 'Semanalmente' : commonRec === 'monthly' ? 'Mensalmente' : 'Recorrente';
                    const clearX = document.createElement('button');
                    clearX.textContent = '‚úï';
                    clearX.style.marginLeft = '8px';
                    clearX.style.border = 'none';
                    clearX.style.background = 'transparent';
                    clearX.addEventListener('click', () => {
                        const bidx = flashcardBatches.findIndex(bb => bb.id === b.id);
                        if (bidx !== -1) {
                            (indices || []).forEach(ci => { if (flashcardBatches[bidx].cards && flashcardBatches[bidx].cards[ci]) { flashcardBatches[bidx].cards[ci].recurring = null; flashcardBatches[bidx].cards[ci].nextReview = null; } });
                            saveFlashcardBatches();
                            renderReviewList();
                            updateReviewIndicator();
                        }
                    });
                    pill.appendChild(clearX);
                    actions.appendChild(pill);
                }
                actions.appendChild(reviewBtnSingle);
                actions.appendChild(agendarBatchBtn);
                actions.appendChild(recurBatchBtn);
                div.appendChild(actions);
                reviewList.appendChild(div);
            });
        }
        document.getElementById('newBatchBtn').addEventListener('click', () => { document.getElementById('batchName').value=''; document.getElementById('cardsContainer').innerHTML=''; document.getElementById('cardsContainer').appendChild(createCardRow()); openModal(newBatchModal); });
        closeNewBatchModal.addEventListener('click', () => closeModalWindow(newBatchModal));
        document.getElementById('addCardBtn').addEventListener('click', () => { document.getElementById('cardsContainer').appendChild(createCardRow()); });

        // editingBatchId: if set, save updates to existing batch instead of creating new
        let editingBatchId = null;
        document.getElementById('saveBatchBtn').addEventListener('click', async () => {
            const name = document.getElementById('batchName').value.trim();
            if (!name) { alert('Nome do lote √© obrigat√≥rio'); return; }
            const rows = Array.from(document.getElementById('cardsContainer').querySelectorAll('.card-row'));
            const cards = [];
            for (const r of rows) {
                const front = r.querySelector('.card-front').value.trim();
                const back = r.querySelector('.card-back').value.trim();
                let audioFront = null; let audioBack = null;
                const fa = r.querySelector('.card-front-audio').files[0];
                const ba = r.querySelector('.card-back-audio').files[0];
                if (fa) {
                    audioFront = await new Promise(res => { const fr = new FileReader(); fr.onload = e => res(e.target.result); fr.readAsDataURL(fa); });
                }
                if (ba) {
                    audioBack = await new Promise(res => { const fr = new FileReader(); fr.onload = e => res(e.target.result); fr.readAsDataURL(ba); });
                }
                const reviewFlag = !!(r.querySelector('.card-review-flag') && r.querySelector('.card-review-flag').checked);
                if (front || back || audioFront || audioBack || reviewFlag) {
                    cards.push({ front, back, audioFront, audioBack, review: reviewFlag });
                }
            }
            if (editingBatchId) {
                const bidx = flashcardBatches.findIndex(b => b.id === editingBatchId);
                if (bidx !== -1) {
                    flashcardBatches[bidx].name = name;
                    flashcardBatches[bidx].cards = cards;
                    flashcardBatches[bidx].updatedAt = new Date().toISOString();
                }
                editingBatchId = null;
            } else {
                const batch = { id: 'batch-' + Date.now().toString(36), name, createdAt: new Date().toISOString(), cards };
                flashcardBatches.push(batch);
            }
            saveFlashcardBatches();
            refreshBatchSelect();
            closeModalWindow(newBatchModal);
            try { updateReviewIndicator(); } catch(e) {}
            alert('Lote salvo.');
        });

        closeStudyModal.addEventListener('click', () => closeModalWindow(studyModal));
        document.getElementById('studyBatchBtn').addEventListener('click', () => {
            const sel = document.getElementById('batchSelect');
            const id = sel.value;
            if (!id) { alert('Selecione um lote'); return; }
            const batch = flashcardBatches.find(b => b.id === id);
            if (!batch || !batch.cards || batch.cards.length === 0) { alert('Lote vazio'); return; }
            startStudy(batch);
        });

        // Edit and Delete handlers
        document.getElementById('editBatchBtn').addEventListener('click', () => {
            const sel = document.getElementById('batchSelect');
            const id = sel.value;
            if (!id) { alert('Selecione um lote para editar'); return; }
            const batch = flashcardBatches.find(b => b.id === id);
            if (!batch) { alert('Lote n√£o encontrado'); return; }
            // populate newBatchModal with batch data
            document.getElementById('batchName').value = batch.name;
            const container = document.getElementById('cardsContainer');
            container.innerHTML = '';
            (batch.cards || []).forEach(c => container.appendChild(createCardRow(c)));
            editingBatchId = batch.id;
            openModal(newBatchModal);
        });

        document.getElementById('deleteBatchBtn').addEventListener('click', () => {
            const sel = document.getElementById('batchSelect');
            const id = sel.value;
            if (!id) { alert('Selecione um lote para excluir'); return; }
            if (!confirm('Deseja realmente excluir este lote?')) return;
            flashcardBatches = flashcardBatches.filter(b => b.id !== id);
            saveFlashcardBatches();
            refreshBatchSelect();
            try { updateReviewIndicator(); } catch(e) {}
            alert('Lote exclu√≠do');
        });

        // Study logic
        let studyState = null;
        function startStudy(batch) {
            studyState = { batchId: batch.id, cards: batch.cards.slice(), index: 0, showBack: false };
            document.getElementById('studyTitle').textContent = 'Estudando: ' + batch.name;
            openModal(studyModal);
            renderCard();
        }
        function renderCard() {
            if (!studyState) return;
            const card = studyState.cards[studyState.index];
            document.getElementById('cardFront').textContent = card.front || '';
            const audioEl = document.getElementById('cardAudio');
            // show front audio when front visible, show back audio when back visible
            if (!studyState.showBack && card.audioFront) {
                audioEl.src = card.audioFront;
                audioEl.style.display = 'block';
            } else if (studyState.showBack && card.audioBack) {
                audioEl.src = card.audioBack;
                audioEl.style.display = 'block';
            } else {
                audioEl.src = '';
                audioEl.style.display = 'none';
            }
            document.getElementById('cardBack').textContent = card.back || '';
            document.getElementById('cardBack').style.display = studyState.showBack ? 'block' : 'none';
        }
        document.getElementById('flipCardBtn').addEventListener('click', () => { if (!studyState) return; studyState.showBack = !studyState.showBack; renderCard(); });
        document.getElementById('nextCardBtn').addEventListener('click', () => { if (!studyState) return; studyState.index = (studyState.index + 1) % studyState.cards.length; studyState.showBack = false; renderCard(); });
        document.getElementById('prevCardBtn').addEventListener('click', () => { if (!studyState) return; studyState.index = (studyState.index - 1 + studyState.cards.length) % studyState.cards.length; studyState.showBack = false; renderCard(); });
        document.getElementById('shuffleCardsBtn').addEventListener('click', () => { if (!studyState) return; for (let i = studyState.cards.length -1; i>0; i--) { const j = Math.floor(Math.random()* (i+1)); [studyState.cards[i], studyState.cards[j]] = [studyState.cards[j], studyState.cards[i]]; } studyState.index = 0; studyState.showBack = false; renderCard(); });

        // initial populate
        refreshBatchSelect();
        // Keyboard shortcuts for study modal
        document.addEventListener('keydown', (e) => {
            if (!studyModal || studyModal.style.display !== 'block') return;
            if (!studyState) return;
            if (e.key === ' ' || e.code === 'Space') { e.preventDefault(); studyState.showBack = !studyState.showBack; renderCard(); }
            else if (e.key === 'ArrowRight') { studyState.index = (studyState.index + 1) % studyState.cards.length; studyState.showBack = false; renderCard(); }
            else if (e.key === 'ArrowLeft') { studyState.index = (studyState.index - 1 + studyState.cards.length) % studyState.cards.length; studyState.showBack = false; renderCard(); }
            else if (e.key === 'Escape') { closeModalWindow(studyModal); }
        });
        const randomExerciseContainer = document.getElementById('randomExerciseContainer');
        const randomExerciseContent = document.getElementById('randomExerciseContent');
        const closeRandomBtn = document.getElementById('closeRandomBtn');
        const prevRandomBtn = document.getElementById('prevRandomBtn');
        const nextRandomBtn = document.getElementById('nextRandomBtn');
        const reviewOkBtn = document.getElementById('reviewOkBtn');
        let isReviewMode = false;
        const randomCounter = document.getElementById('randomCounter');

        function openModal(modal) {
            modal.style.display = 'block';
            document.body.style.overflow = 'hidden';
        }

        function closeModalWindow(modal) {
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // ===== GERENCIAMENTO DE TAGS =====
        // Extrai todas as tags √∫nicas dos exerc√≠cios
        function getAllExistingTags() {
            const allTags = new Set();
            exercises.forEach(ex => {
                if (ex.tags && Array.isArray(ex.tags)) {
                    ex.tags.forEach(tag => allTags.add(tag));
                }
            });
            return Array.from(allTags).sort();
        }

        // Inicializa o seletor de tags com busca
        function initializeTagSelector(containerId, selectedTagsDisplayId, newTagInputId, hiddenInputId, modalType = 'new') {
            const existingTagsContainer = document.getElementById(containerId);
            const selectedTagsDisplay = document.getElementById(selectedTagsDisplayId);
            const newTagInput = document.getElementById(newTagInputId);
            const hiddenInput = document.getElementById(hiddenInputId);
            
            // Obter IDs do campo de busca baseado no tipo de modal
            const searchInputId = modalType === 'edit' ? 'editTagSearchInput' : 'tagSearchInput';
            const countInfoId = modalType === 'edit' ? 'editTagCountInfo' : 'tagCountInfo';
            const displayInfoId = modalType === 'edit' ? 'editTagDisplayInfo' : 'tagDisplayInfo';
            
            const tagSearchInput = document.getElementById(searchInputId);
            const tagCountInfo = document.getElementById(countInfoId);
            const tagDisplayInfo = document.getElementById(displayInfoId);
            
            const allTags = getAllExistingTags();
            let selectedTags = new Set();
            let filteredTags = [...allTags];

            // Se for edi√ß√£o, carrega as tags j√° selecionadas
            if (modalType === 'edit' && editingIndex !== null && exercises[editingIndex].tags) {
                selectedTags = new Set(exercises[editingIndex].tags);
            }

            // Renderiza as tags existentes (filtrando conforme busca)
            function renderExistingTags() {
                existingTagsContainer.innerHTML = '';
                
                if (filteredTags.length === 0) {
                    existingTagsContainer.innerHTML = '<div class="no-tags-message">Nenhuma etiqueta encontrada</div>';
                    return;
                }
                
                filteredTags.forEach(tag => {
                    const chip = document.createElement('div');
                    chip.className = 'tag-chip' + (selectedTags.has(tag) ? ' selected' : '');
                    chip.textContent = tag;
                    chip.addEventListener('click', () => {
                        if (selectedTags.has(tag)) {
                            selectedTags.delete(tag);
                            chip.classList.remove('selected');
                        } else {
                            selectedTags.add(tag);
                            chip.classList.add('selected');
                        }
                        updateDisplay();
                    });
                    existingTagsContainer.appendChild(chip);
                });
                
                // Atualizar contadores
                if (tagCountInfo) tagCountInfo.textContent = allTags.length;
                if (tagDisplayInfo) tagDisplayInfo.textContent = filteredTags.length;
            }

            // Atualiza a exibi√ß√£o das tags selecionadas
            function updateDisplay() {
                selectedTagsDisplay.innerHTML = '';
                const sortedSelected = Array.from(selectedTags).sort();
                if (sortedSelected.length === 0) {
                    selectedTagsDisplay.innerHTML = '<span style="color: #999; font-style: italic;">Nenhuma etiqueta selecionada</span>';
                } else {
                    sortedSelected.forEach(tag => {
                        const chip = document.createElement('div');
                        chip.className = 'tag-chip selected';
                        chip.innerHTML = tag + ' <span style="margin-left: 5px; cursor: pointer; font-weight: bold;">&times;</span>';
                        chip.style.cursor = 'pointer';
                        chip.addEventListener('click', () => {
                            selectedTags.delete(tag);
                            renderExistingTags();
                            updateDisplay();
                        });
                        selectedTagsDisplay.appendChild(chip);
                    });
                }
                // Atualiza o input hidden com as tags selecionadas
                hiddenInput.value = Array.from(selectedTags).join(', ');
            }

            // Filtro de busca
            if (tagSearchInput) {
                // remove qualquer handler anterior e use oninput para evitar listeners duplicados
                tagSearchInput.oninput = function(e) {
                    const searchValue = e.target.value.toLowerCase().trim();
                    if (searchValue === '') {
                        filteredTags = [...allTags];
                    } else {
                        filteredTags = allTags.filter(tag => 
                            tag.toLowerCase().includes(searchValue)
                        );
                    }
                    renderExistingTags();
                };
            }

            // Permite adicionar novas tags via input
            if (newTagInput) {
                // remover qualquer handler anterior e usar onkeypress para garantir apenas um listener
                newTagInput.onkeypress = function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        let newTag = newTagInput.value.trim();
                        if (newTag) {
                            if (!newTag.startsWith('#')) {
                                newTag = '#' + newTag;
                            }
                            selectedTags.add(newTag);
                            newTagInput.value = '';
                            renderExistingTags();
                            updateDisplay();
                        }
                    }
                };
            }

            // Renderiza inicial
            renderExistingTags();
            updateDisplay();
        }

        const form = document.getElementById('exerciseForm');
        const exerciseList = document.getElementById('exerciseList');
        const modal = document.getElementById('annotationModal');
        const closeModal = document.getElementById('closeModal');
        const saveAnnotation = document.getElementById('saveAnnotation');
        const annotationText = document.getElementById('annotationText');
        const addAlternativeBtn = document.getElementById('addAlternative');
        const alternativesContainer = document.getElementById('alternativesContainer');
        const submitBtn = document.getElementById('submitBtn');
        const editModal = document.getElementById('editModal');
        const closeEditModal = document.getElementById('closeEditModal');
        const saveEdit = document.getElementById('saveEdit');
        const editAddAlternativeBtn = document.getElementById('editAddAlternative');
        const editAlternativesContainer = document.getElementById('editAlternativesContainer');
        const newModal = document.getElementById('newModal');
        const closeNewModal = document.getElementById('closeNewModal');
        const newExerciseBtn = document.getElementById('newExerciseBtn');
        const searchInput = document.getElementById('searchInput');
        const sortSelect = document.getElementById('sortSelect');
        const statusSelect = document.getElementById('statusSelect');
        const statsBtn = document.getElementById('statsBtn');
        const statsModal = document.getElementById('statsModal');
        const closeStatsModal = document.getElementById('closeStatsModal');
        const saveStats = document.getElementById('saveStats');
        const statsSection = document.getElementById('statsSection');
        const statsList = document.getElementById('statsList');
        const addStatsBtn = document.getElementById('addStatsBtn');
        const simuladoBtn = document.getElementById('simuladoBtn');
        const simuladoSection = document.getElementById('simuladoSection');
        const simuladoList = document.getElementById('simuladoList');
        const submitSimulado = document.getElementById('submitSimulado');
        const createSimuladoBtn = document.getElementById('createSimuladoBtn');
        const simuladoModal = document.getElementById('simuladoModal');
        const closeSimuladoModal = document.getElementById('closeSimuladoModal');
        const startSimulado = document.getElementById('startSimulado');
        const historyList = document.getElementById('historyList');
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');

        const exportBtn = document.getElementById('exportBtn');
        const importBtn = document.getElementById('importBtn');
        const importFile = document.getElementById('importFile');
        const tagsBtn = document.getElementById('tagsBtn');
        const tagsModal = document.getElementById('tagsModal');
        const closeTagsModal = document.getElementById('closeTagsModal');
        const tagsList = document.getElementById('tagsList');
        const clearTagFilter = document.getElementById('clearTagFilter');

        addAlternativeBtn.addEventListener('click', addAlternativeInput);
        editAddAlternativeBtn.addEventListener('click', addEditAlternativeInput);
        newExerciseBtn.addEventListener('click', () => {
            openModal(newModal);
            // Limpa o form quando abre
            document.getElementById('exerciseForm').reset();
            document.getElementById('newTagInput').value = '';
            // Inicializa o seletor de tags
            initializeTagSelector('existingTags', 'selectedTagsDisplay', 'newTagInput', 'tags', 'new');
        });
        // Category buttons (main categories) - clicking selects the category
        document.querySelectorAll('.category-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Collapse/expand subcategory list if present
                const next = btn.nextElementSibling;
                if (next && next.classList && next.classList.contains('subcat-list')) {
                    // toggle display
                    next.style.display = next.style.display === 'none' ? 'block' : 'none';
                }

                // Remove active state from all category and subcategory buttons
                document.querySelectorAll('.category-btn, .subcategory-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('statsBtn').classList.remove('active');

                // If this main category has subcategories, selecting the main category shows its exercises
                currentCategory = btn.dataset.category;
                currentPage = 1;
                if (isRandomMode) {
                    startRandomMode();
                } else {
                    showExercises();
                }
            });
        });

        // Subcategory buttons - selecting a subcategory filters to that subcategory
        document.querySelectorAll('.subcategory-btn').forEach(sbtn => {
            sbtn.addEventListener('click', (e) => {
                e.stopPropagation();
                // Clear active states
                document.querySelectorAll('.category-btn, .subcategory-btn').forEach(b => b.classList.remove('active'));
                // Highlight both parent and sub
                sbtn.classList.add('active');
                const parent = sbtn.dataset.parent;
                const parentBtn = document.querySelector(`.category-btn[data-category="${parent}"]`);
                if (parentBtn) parentBtn.classList.add('active');

                document.getElementById('statsBtn').classList.remove('active');
                currentCategory = sbtn.dataset.category;
                currentPage = 1;
                if (isRandomMode) {
                    startRandomMode();
                } else {
                    showExercises();
                }
            });
        });

        searchInput.addEventListener('input', () => {
            searchTerm = searchInput.value.trim().toLowerCase();
            currentPage = 1;
            showExercises();
        });

        sortSelect.addEventListener('change', () => {
            sortOrder = sortSelect.value;
            currentPage = 1;
            showExercises();
        });

        statusSelect.addEventListener('change', () => {
            currentStatus = statusSelect.value;
            currentPage = 1;
            showExercises();
        });

        statsBtn.addEventListener('click', () => {
            document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
            showStats();
        });

        addStatsBtn.addEventListener('click', openStatsModal);

        simuladoBtn.addEventListener('click', () => {
            document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('statsBtn').classList.remove('active');
            simuladoBtn.classList.add('active');
            showSimulado();
        });

        createSimuladoBtn.addEventListener('click', () => openModal(simuladoModal));

        clearHistoryBtn.addEventListener('click', () => {
            if (confirm('Tem certeza que deseja limpar o hist√≥rico de simulados?')) {
                simuladoHistory = [];
                localStorage.setItem('simuladoHistory', JSON.stringify(simuladoHistory));
                displaySimuladoStats();
                displaySimuladoHistory();
            }
        });

        exportBtn.addEventListener('click', exportData);
        importBtn.addEventListener('click', () => importFile.click());
        importFile.addEventListener('change', importData);

        tagsBtn.addEventListener('click', () => { displayTags(); openModal(tagsModal); });
        closeTagsModal.addEventListener('click', () => closeModalWindow(tagsModal));
        clearTagFilter.addEventListener('click', () => { searchInput.value = ''; searchTerm = ''; closeModalWindow(tagsModal); currentPage = 1; showExercises(); });

        // Storage Management
        const storageBtn = document.getElementById('storageBtn');
        const storageModal = document.getElementById('storageModal');
        const closeStorageModal = document.getElementById('closeStorageModal');
        
        function calculateStorageSize() {
            let total = 0;
            for (let key in localStorage) {
                if (localStorage.hasOwnProperty(key)) {
                    total += localStorage[key].length;
                }
            }
            return total;
        }
        
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
        }
        
        async function updateStorageInfo() {
            const localStorageSize = calculateStorageSize();
            const usedStorageSpan = document.getElementById('usedStorage');
            const totalExercisesSpan = document.getElementById('totalExercises');
            const avgSizeSpan = document.getElementById('avgSize');
            
            // Calculate IndexedDB size
            let indexedDBSize = 0;
            if (exercises.length > 0) {
                indexedDBSize = JSON.stringify(exercises).length;
                indexedDBSize += JSON.stringify(stats).length;
                indexedDBSize += JSON.stringify(timers).length;
                indexedDBSize += JSON.stringify(simuladoHistory).length;
            }
            
            const totalSize = localStorageSize + indexedDBSize;
            usedStorageSpan.innerHTML = `
                <strong>localStorage:</strong> ${formatBytes(localStorageSize)}<br>
                <strong>IndexedDB:</strong> ${formatBytes(indexedDBSize)}<br>
                <strong>Total:</strong> ${formatBytes(totalSize)}
            `;
            totalExercisesSpan.textContent = exercises.length;
            
            if (exercises.length > 0) {
                const avgSize = Math.round(indexedDBSize / exercises.length);
                avgSizeSpan.textContent = formatBytes(avgSize);
            } else {
                avgSizeSpan.textContent = '0 KB';
            }
        }
        
        storageBtn.addEventListener('click', () => {
            updateStorageInfo();
            openModal(storageModal);
        });
        
        closeStorageModal.addEventListener('click', () => closeModalWindow(storageModal));
        
        document.getElementById('calculateStorageBtn').addEventListener('click', updateStorageInfo);
        
        document.getElementById('cleanupStorageBtn').addEventListener('click', async () => {
            const clearExercises = document.getElementById('clearExercises').checked;
            const clearStats = document.getElementById('clearStats').checked;
            const clearSimulado = document.getElementById('clearSimulado').checked;
            const clearTimers = document.getElementById('clearTimers').checked;
            
            if (!clearExercises && !clearStats && !clearSimulado && !clearTimers) {
                alert('Selecione pelo menos um item para limpar!');
                return;
            }
            
            if (confirm('Tem certeza? Esta a√ß√£o n√£o pode ser desfeita!')) {
                if (clearExercises) {
                    exercises = [];
                    localStorage.removeItem('exercises');
                    if (db) clearIndexedDBStore(STORES.exercises);
                }
                if (clearStats) {
                    stats = {};
                    localStorage.removeItem('stats');
                    if (db) clearIndexedDBStore(STORES.stats);
                }
                if (clearSimulado) {
                    simuladoHistory = [];
                    localStorage.removeItem('simuladoHistory');
                    if (db) clearIndexedDBStore(STORES.simuladoHistory);
                }
                if (clearTimers) {
                    timers = {};
                    localStorage.removeItem('timers');
                    if (db) clearIndexedDBStore(STORES.timers);
                }
                
                alert('‚úÖ Dados limpos com sucesso!');
                updateStorageInfo();
                if (clearExercises) {
                    displayExercises();
                    closeModalWindow(storageModal);
                }
            }
        });

        // ============================================
        // DROPBOX EVENT LISTENERS
        // ============================================
        document.getElementById('dropboxLoginBtn').addEventListener('click', async () => {
            await dropboxManager.authenticate();
        });

        document.getElementById('dropboxSyncBtn').addEventListener('click', async () => {
            if (isSyncing) {
                alert('‚è≥ Sincroniza√ß√£o em andamento. Aguarde...');
                return;
            }
            
            isSyncing = true;
            try {
                const dataToSync = {
                    exercises: exercises,
                    stats: stats,
                    timers: timers,
                    simuladoHistory: simuladoHistory,
                    lastSync: new Date().toISOString()
                };
                const success = await dropboxManager.uploadToDropbox(dataToSync);
                if (success) {
                    pendingSync = false;
                    // Save locally as cache after successful upload
                    await saveToStorage('exercises', exercises);
                    await saveToStorage('stats', stats);
                    await saveToStorage('timers', timers);
                    await saveToStorage('simuladoHistory', simuladoHistory);
                    console.log('‚úÖ Sincroniza√ß√£o completa: dados salvos em IndexedDB/localStorage como cache');
                }
            } finally {
                isSyncing = false;
            }
        });

        document.getElementById('dropboxRestoreBtn').addEventListener('click', async () => {
            if (confirm('Tem certeza que deseja restaurar dados do Dropbox? Os dados locais ser√£o sobrescrito!')) {
                const restoredData = await dropboxManager.downloadFromDropbox();
                if (restoredData) {
                    exercises = restoredData.exercises || [];
                    stats = restoredData.stats || {};
                    timers = restoredData.timers || {};
                    simuladoHistory = restoredData.simuladoHistory || [];
                    
                    // Save to local storage
                    await saveToStorage('exercises', exercises);
                    await saveToStorage('stats', stats);
                    await saveToStorage('timers', timers);
                    await saveToStorage('simuladoHistory', simuladoHistory);
                    
                    displayExercises();
                    updateStorageInfo();
                    alert('‚úÖ Dados restaurados com sucesso!');
                }
            }
        });

        document.getElementById('dropboxLogoutBtn').addEventListener('click', () => {
            if (confirm('Tem certeza que deseja desconectar do Dropbox?')) {
                dropboxManager.logout();
                alert('Desconectado do Dropbox com sucesso!');
            }
        });

        // Atualizar status do Dropbox ao abrir modal
        storageBtn.addEventListener('click', () => {
            updateDropboxStatus();
        });        const simuladoForm = document.getElementById('simuladoForm');

        closeSimuladoModal.addEventListener('click', () => closeModalWindow(simuladoModal));

        startSimulado.addEventListener('click', startNewSimulado);

        addAlternativeBtn.addEventListener('click', addAlternativeInput);

        function addAlternativeInput(value = '') {
            const div = document.createElement('div');
            div.className = 'alternative-input';
            div.innerHTML = `
                <input type="text" value="${value}" placeholder="Digite a alternativa">
                <button type="button" class="remove-alt">Remover</button>
            `;
            div.querySelector('.remove-alt').addEventListener('click', () => {
                div.remove();
                updateCorrectAltOptions();
            });
            alternativesContainer.appendChild(div);
            updateCorrectAltOptions();
        }

        function updateCorrectAltOptions() {
            const select = document.getElementById('correctAlt');
            const currentValue = select.value;
            select.innerHTML = '<option value="">Selecione</option>';
            const inputs = alternativesContainer.querySelectorAll('input');
            inputs.forEach((input, index) => {
                if (input.value.trim()) {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = input.value.trim();
                    select.appendChild(option);
                }
            });
            if (currentValue && select.querySelector(`option[value="${currentValue}"]`)) {
                select.value = currentValue;
            }
        }

        function addEditAlternativeInput(value = '') {
            const div = document.createElement('div');
            div.className = 'alternative-input';
            div.innerHTML = `
                <input type="text" value="${value}" placeholder="Digite a alternativa">
                <button type="button" class="remove-alt">Remover</button>
            `;
            div.querySelector('.remove-alt').addEventListener('click', () => {
                div.remove();
                updateEditCorrectAltOptions();
            });
            editAlternativesContainer.appendChild(div);
            updateEditCorrectAltOptions();
        }

        function updateEditCorrectAltOptions() {
            const select = document.getElementById('editCorrectAlt');
            const currentValue = select.value;
            select.innerHTML = '<option value="">Selecione</option>';
            const inputs = editAlternativesContainer.querySelectorAll('input');
            inputs.forEach((input, index) => {
                if (input.value.trim()) {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = input.value.trim();
                    select.appendChild(option);
                }
            });
            if (currentValue && select.querySelector(`option[value="${currentValue}"]`)) {
                select.value = currentValue;
            }
        }

        // Multi-image storage
        let selectedImages = [];
        let isProcessing = false;
        
        // Compress image to reduce storage size - intelligently based on size
        function compressImage(dataUrl, quality = 0.7) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
                    let finalQuality = quality;
                    
                    // Calculate original size (rough estimate)
                    const originalSize = dataUrl.length;
                    
                    // Adaptive compression based on original size
                    if (originalSize > 5000000) {
                        // >5MB: aggressive compression
                        finalQuality = 0.4;
                    } else if (originalSize > 2000000) {
                        // >2MB: strong compression
                        finalQuality = 0.5;
                    } else if (originalSize > 1000000) {
                        // >1MB: normal compression
                        finalQuality = 0.6;
                    }
                    
                    // Resize if too large (adaptive based on original dimensions)
                    let maxWidth = 1200;
                    if (width > 4000 || height > 4000) {
                        maxWidth = 800;  // Very large images -> smaller
                    } else if (width > 2000 || height > 2000) {
                        maxWidth = 1024; // Large images
                    }
                    
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert to JPEG with compression
                    const compressedUrl = canvas.toDataURL('image/jpeg', finalQuality);
                    
                    // Log compression ratio
                    const compressedSize = compressedUrl.length;
                    const ratio = Math.round((1 - compressedSize / originalSize) * 100);
                    console.log(`üì∏ Imagem comprimida: ${ratio}% menor (${(originalSize/1024/1024).toFixed(2)}MB ‚Üí ${(compressedSize/1024/1024).toFixed(2)}MB)`);
                    
                    resolve(compressedUrl);
                };
                img.onerror = function() {
                    console.error('Erro ao carregar imagem para compress√£o');
                    resolve(dataUrl); // Fallback to original if compression fails
                };
                img.src = dataUrl;
            });
        }
        
        // Fun√ß√£o para limpar o modal de novo exerc√≠cio
        function clearNewExerciseModal() {
            // Limpar formul√°rio
            form.reset();
            
            // Limpar imagens
            selectedImages = [];
            const imageInput = document.getElementById('image');
            imageInput.value = '';
            document.getElementById('multiImagePreview').style.display = 'none';
            document.getElementById('imagesList').innerHTML = '';
            
            // Limpar alternativas
            alternativesContainer.innerHTML = '';
            updateCorrectAltOptions();
            
            // Limpar tags - apenas limpar a sele√ß√£o, sem reinicializar
            const tagsDisplay = document.getElementById('selectedTagsDisplay');
            if (tagsDisplay) {
                tagsDisplay.innerHTML = '<span style="color: #999; font-style: italic;">Nenhuma etiqueta selecionada</span>';
            }
            const tagsInput = document.getElementById('tags');
            if (tagsInput) tagsInput.value = '';
            
            // Limpar chips selecionados no container de tags existentes
            const existingTagsContainer = document.getElementById('existingTags');
            if (existingTagsContainer) {
                const selectedChips = existingTagsContainer.querySelectorAll('.tag-chip.selected');
                selectedChips.forEach(chip => chip.classList.remove('selected'));
            }
            
            // Limpar o input de busca e novo input de tag
            const tagSearchInput = document.getElementById('tagSearchInput');
            if (tagSearchInput) tagSearchInput.value = '';
            const newTagInput = document.getElementById('newTagInput');
            if (newTagInput) newTagInput.value = '';
            
            // Resetar progresso
            document.getElementById('uploadProgress').style.display = 'none';
            isProcessing = false;
            submitBtn.disabled = false;
            // Re-inicializar o seletor de tags para garantir que n√£o haja estado residual
            try {
                initializeTagSelector('existingTags', 'selectedTagsDisplay', 'newTagInput', 'tags', 'new');
            } catch (e) {
                // silent
            }

            // Fechar o modal
            closeModalWindow(newModal);
        }
        
        // Handle multiple image selection
        const imageInput = document.getElementById('image');
        const audioInput = document.getElementById('audio');
        const answerAudioInput = document.getElementById('answerAudio');
        const editAudioInput = document.getElementById('editAudio');
        const editAnswerAudioInput = document.getElementById('editAnswerAudio');
        imageInput.addEventListener('change', function(e) {
            if (isProcessing) return; // Prevent concurrent processing
            
            selectedImages = [];
            const files = Array.from(e.target.files);
            const imagesList = document.getElementById('imagesList');
            imagesList.innerHTML = '';
            
            if (files.length > 0) {
                document.getElementById('multiImagePreview').style.display = 'block';
                let loadedCount = 0;
                
                files.forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = async function(event) {
                        // Compress the image
                        const compressedData = await compressImage(event.target.result, 0.6);
                        
                        selectedImages[index] = {
                            file: file,
                            data: compressedData,
                            title: file.name.replace(/\.[^/.]+$/, '')
                        };
                        
                        loadedCount++;
                        // Only update preview when all images are loaded
                        if (loadedCount === files.length) {
                            updateImagePreview();
                        }
                    };
                    reader.onerror = function() {
                        console.error('Erro ao carregar imagem:', file.name);
                        loadedCount++;
                    };
                    reader.readAsDataURL(file);
                });
            } else {
                document.getElementById('multiImagePreview').style.display = 'none';
            }
        });
        
        function updateImagePreview() {
            const imagesList = document.getElementById('imagesList');
            imagesList.innerHTML = '';
            
            // Filter out empty entries
            const validImages = selectedImages.filter(img => img !== undefined);
            
            validImages.forEach((img, displayIndex) => {
                const actualIndex = selectedImages.indexOf(img);
                if (img) {
                    const div = document.createElement('div');
                    div.className = 'multi-image-item';
                    div.innerHTML = `
                        <img src="${img.data}" class="multi-image-thumbnail" alt="preview">
                        <div class="multi-image-info">
                            <input type="text" class="image-title-input" data-index="${actualIndex}" placeholder="T√≠tulo da imagem" value="${img.title}">
                        </div>
                        <button type="button" class="multi-image-remove" data-index="${actualIndex}">Remover</button>
                    `;
                    
                    div.querySelector('.image-title-input').addEventListener('change', function() {
                        const idx = parseInt(this.getAttribute('data-index'));
                        if (selectedImages[idx]) {
                            selectedImages[idx].title = this.value || selectedImages[idx].file.name.replace(/\.[^/.]+$/, '');
                        }
                    });
                    
                    div.querySelector('.multi-image-remove').addEventListener('click', function(e) {
                        e.preventDefault();
                        const idx = parseInt(this.getAttribute('data-index'));
                        removeImage(idx);
                    });
                    
                    imagesList.appendChild(div);
                }
            });
        }
        
        function removeImage(index) {
            selectedImages[index] = undefined;
            const validImages = selectedImages.filter(img => img !== undefined);
            
            if (validImages.length === 0) {
                selectedImages = [];
                imageInput.value = '';
                document.getElementById('multiImagePreview').style.display = 'none';
            } else {
                selectedImages = validImages;
                updateImagePreview();
            }
        }
        
        const clearImagesBtn = document.getElementById('clearImagesBtn');
        if (clearImagesBtn) {
            clearImagesBtn.addEventListener('click', function(e) {
                e.preventDefault();
                selectedImages = [];
                imageInput.value = '';
                document.getElementById('multiImagePreview').style.display = 'none';
            });
        }

        form.addEventListener('submit', function(e) {
            e.preventDefault();
            
            // Prevent duplicate submissions
            if (isProcessing) {
                return;
            }
            
            isProcessing = true;
            submitBtn.disabled = true;
            
            let baseTitle = document.getElementById('title').value.trim();
            const difficulty = document.getElementById('difficulty').value;
            const category = document.getElementById('category').value;
            const answerImageInput = document.getElementById('answerImage');
            const exerciseText = document.getElementById('exerciseText').value;
            const tagsInput = document.getElementById('tags').value;
            const tags = tagsInput ? tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag.startsWith('#')) : [];
            const reviewFlag = document.getElementById('reviewFlag') ? document.getElementById('reviewFlag').checked : false;
            const recurrenceSel = document.getElementById('recurrence');
            const recurrence = recurrenceSel ? recurrenceSel.value || null : null;
            const nextDateInput = document.getElementById('nextReviewDate');
            const nextReview = nextDateInput && nextDateInput.value ? new Date(nextDateInput.value + 'T00:00:00').toISOString() : null;
            const alternatives = Array.from(alternativesContainer.querySelectorAll('input')).map(input => input.value.trim()).filter(val => val);
            const correctIndex = alternatives.length > 0 ? parseInt(document.getElementById('correctAlt').value) || 0 : null;

            // Validation
            if (!difficulty || !category) {
                alert('Dificuldade e categoria s√£o obrigat√≥rios.');
                isProcessing = false;
                submitBtn.disabled = false;
                return;
            }

            // Filter out undefined entries from selectedImages
            const validImages = selectedImages.filter(img => img !== undefined);

            // If no images and no title, return
            if (validImages.length === 0 && !baseTitle) {
                alert('Por favor, adicione pelo menos um t√≠tulo ou uma imagem.');
                isProcessing = false;
                submitBtn.disabled = false;
                return;
            }

            // If we have multiple images, save each one separately
            if (validImages.length > 0) {
                const progressDiv = document.getElementById('uploadProgress');
                const progressBar = document.getElementById('progressBar');
                const uploadStatus = document.getElementById('uploadStatus');
                
                progressDiv.style.display = 'block';
                progressBar.style.width = '0%';
                progressBar.textContent = '0%';
                
                // Read answer image and audio first if exist
                let answerImageData = null;
                let audioData = null;
                let answerAudioData = null;

                const readAndContinue = async () => {
                    saveMultipleImages(validImages, baseTitle, difficulty, category, exerciseText, answerImageData, alternatives, correctIndex, tags, progressBar, uploadStatus, reviewFlag, audioData, answerAudioData, nextReview, recurrence);
                };

                // Read answer image if present
                if (answerImageInput.files[0]) {
                    const reader = new FileReader();
                    reader.onload = async function(event) {
                        answerImageData = await compressImage(event.target.result, 0.6);
                        // after reading image, try reading audios (if any)
                        if (audioInput && audioInput.files[0]) {
                            const r2 = new FileReader();
                            r2.onload = function(ev2) {
                                audioData = ev2.target.result;
                                if (answerAudioInput && answerAudioInput.files[0]) {
                                    const r3 = new FileReader();
                                    r3.onload = function(ev3) {
                                        answerAudioData = ev3.target.result;
                                        readAndContinue();
                                    };
                                    r3.readAsDataURL(answerAudioInput.files[0]);
                                } else {
                                    readAndContinue();
                                }
                            };
                            r2.readAsDataURL(audioInput.files[0]);
                        } else if (answerAudioInput && answerAudioInput.files[0]) {
                            const r3 = new FileReader();
                            r3.onload = function(ev3) {
                                answerAudioData = ev3.target.result;
                                readAndContinue();
                            };
                            r3.readAsDataURL(answerAudioInput.files[0]);
                        } else {
                            readAndContinue();
                        }
                    };
                    reader.onerror = function() {
                        alert('Erro ao carregar imagem de resposta');
                        isProcessing = false;
                        submitBtn.disabled = false;
                        progressDiv.style.display = 'none';
                    };
                    reader.readAsDataURL(answerImageInput.files[0]);
                } else {
                    // No answer image, read audios if present then continue
                    if (audioInput && audioInput.files[0]) {
                        const r2 = new FileReader();
                        r2.onload = function(ev2) {
                            audioData = ev2.target.result;
                            if (answerAudioInput && answerAudioInput.files[0]) {
                                const r3 = new FileReader();
                                r3.onload = function(ev3) {
                                    answerAudioData = ev3.target.result;
                                    readAndContinue();
                                };
                                r3.readAsDataURL(answerAudioInput.files[0]);
                            } else {
                                readAndContinue();
                            }
                        };
                        r2.readAsDataURL(audioInput.files[0]);
                    } else if (answerAudioInput && answerAudioInput.files[0]) {
                        const r3 = new FileReader();
                        r3.onload = function(ev3) {
                            answerAudioData = ev3.target.result;
                            readAndContinue();
                        };
                        r3.readAsDataURL(answerAudioInput.files[0]);
                    } else {
                        saveMultipleImages(validImages, baseTitle, difficulty, category, exerciseText, null, alternatives, correctIndex, tags, progressBar, uploadStatus, reviewFlag, null, null);
                    }
                }
            } else {
                // Single exercise with no images - handle optional audios
                let answerImageData = null;
                let audioData = null;
                let answerAudioData = null;

                const finishSingleSave = () => {
                    saveExercise(baseTitle, difficulty, category, null, exerciseText, answerImageData, alternatives, correctIndex, tags, reviewFlag, audioData, answerAudioData, nextReview, recurrence);
                    clearNewExerciseModal();
                };

                if (answerImageInput.files[0]) {
                    const reader = new FileReader();
                    reader.onload = async function(event) {
                        answerImageData = await compressImage(event.target.result, 0.6);
                        // read audios if present
                        if (audioInput && audioInput.files[0]) {
                            const r2 = new FileReader();
                            r2.onload = function(ev2) {
                                audioData = ev2.target.result;
                                if (answerAudioInput && answerAudioInput.files[0]) {
                                    const r3 = new FileReader();
                                    r3.onload = function(ev3) { answerAudioData = ev3.target.result; finishSingleSave(); };
                                    r3.readAsDataURL(answerAudioInput.files[0]);
                                } else {
                                    finishSingleSave();
                                }
                            };
                            r2.readAsDataURL(audioInput.files[0]);
                        } else if (answerAudioInput && answerAudioInput.files[0]) {
                            const r3 = new FileReader();
                            r3.onload = function(ev3) { answerAudioData = ev3.target.result; finishSingleSave(); };
                            r3.readAsDataURL(answerAudioInput.files[0]);
                        } else {
                            finishSingleSave();
                        }
                    };
                    reader.onerror = function() {
                        alert('Erro ao carregar imagem de resposta');
                        isProcessing = false;
                        submitBtn.disabled = false;
                    };
                    reader.readAsDataURL(answerImageInput.files[0]);
                } else {
                    // No answer image, read audios if any
                    if (audioInput && audioInput.files[0]) {
                        const r2 = new FileReader();
                        r2.onload = function(ev2) {
                            audioData = ev2.target.result;
                            if (answerAudioInput && answerAudioInput.files[0]) {
                                const r3 = new FileReader();
                                r3.onload = function(ev3) { answerAudioData = ev3.target.result; finishSingleSave(); };
                                r3.readAsDataURL(answerAudioInput.files[0]);
                            } else {
                                finishSingleSave();
                            }
                        };
                        r2.readAsDataURL(audioInput.files[0]);
                    } else if (answerAudioInput && answerAudioInput.files[0]) {
                        const r3 = new FileReader();
                        r3.onload = function(ev3) { answerAudioData = ev3.target.result; finishSingleSave(); };
                        r3.readAsDataURL(answerAudioInput.files[0]);
                    } else {
                        finishSingleSave();
                    }
                }
            }
        });
        
        function saveMultipleImages(images, baseTitle, difficulty, category, exerciseText, answerImageData, alternatives, correctIndex, tags, progressBar, uploadStatus, reviewFlag = false, audioData = null, answerAudioData = null, nextReview = null, recurring = null) {
            // Filter only valid images for counting
            const validImages = images.filter(img => img && img.data);
            const total = validImages.length;
            let savedCount = 0;
            
            if (total === 0) {
                isProcessing = false;
                submitBtn.disabled = false;
                return;
            }
            
            validImages.forEach((img, index) => {
                const title = img.title || baseTitle || `Exerc√≠cio ${index + 1}`;
                
                // Use Promise to ensure proper sequencing
                Promise.resolve().then(() => {
                    return new Promise((resolve) => {
                        setTimeout(() => {
                            saveExercise(title, difficulty, category, img.data, exerciseText, answerImageData, alternatives, correctIndex, tags, reviewFlag, audioData, answerAudioData, nextReview, recurring);
                            
                            savedCount++;
                            const percentage = Math.round((savedCount / total) * 100);
                            progressBar.style.width = percentage + '%';
                            progressBar.textContent = percentage + '%';
                            uploadStatus.textContent = `${savedCount} de ${total} imagem(ns) carregada(s)...`;
                            
                            console.log(`Salvando imagem ${savedCount} de ${total}`);
                            
                            if (savedCount === total) {
                                setTimeout(() => {
                                    document.getElementById('uploadProgress').style.display = 'none';
                                    progressBar.style.width = '0%';
                                    progressBar.textContent = '0%';
                                    uploadStatus.textContent = 'Carregando...';
                                    isProcessing = false;
                                    submitBtn.disabled = false;
                                    clearNewExerciseModal();
                                    console.log('Upload conclu√≠do!');
                                }, 500);
                            }
                            
                            resolve();
                        }, index * 200); // Increased delay for better visibility
                    });
                });
            });
        }

        function saveExercise(title, difficulty, category, imageData, exerciseText, answerImageData, alternatives, correctIndex, tags = [], review = false, audioData = null, answerAudioData = null, nextReview = null, recurring = null) {
            try {
                const now = new Date().toISOString();
                // Ensure exercise has a stable id
                function generateId() { return 'ex-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,6); }
                const exercise = {
                    id: generateId(),
                    title,
                    difficulty,
                    category,
                    image: imageData,
                    audio: audioData,
                    text: exerciseText,
                    answerImage: answerImageData,
                    answerAudio: answerAudioData,
                    review: !!review,
                    nextReview: nextReview || null,
                    recurring: recurring || null,
                    alternatives,
                    correctIndex,
                    annotations: '',
                    tags,
                    status: 'not-done',
                    done: false,
                    favorite: false,
                    createdAt: now,
                    updatedAt: now
                };
                exercises.push(exercise);
                saveToLocalStorage('exercises', exercises);
                displayExercises();
                try { if (typeof updateReviewIndicator === 'function') updateReviewIndicator(); } catch(e) {}
                
                console.log('Exerc√≠cio salvo:', title);
            } catch (error) {
                console.error('Erro ao salvar exerc√≠cio:', error);
                alert('Erro ao salvar exerc√≠cio. Verifique o console.');
            }
        }

        function displayExercises() {
            if (currentView !== 'exercises') return;
            if (sortOrder === 'recent') {
                exercises.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
            } else if (sortOrder === 'oldest') {
                exercises.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
            } else if (sortOrder === 'easy-first') {
                const diffOrder = { easy: 1, medium: 2, hard: 3 };
                exercises.sort((a, b) => diffOrder[a.difficulty] - diffOrder[b.difficulty]);
            } else if (sortOrder === 'hard-first') {
                const diffOrder = { easy: 1, medium: 2, hard: 3 };
                exercises.sort((a, b) => diffOrder[b.difficulty] - diffOrder[a.difficulty]);
            }
            let filteredIndices = [];
            exercises.forEach((exercise, index) => {
                if (currentCategory !== 'Todos' && exercise.category !== currentCategory) return;
                const exerciseStatus = exercise.status || 'not-done';
                if (currentStatus === 'done' && exerciseStatus !== 'done') return;
                if (currentStatus === 'not-done' && exerciseStatus !== 'not-done') return;
                if (currentStatus === 'in-progress' && exerciseStatus !== 'in-progress') return;
                if (currentStatus === 'favorites' && !exercise.favorite) return;
                if (searchTerm) {
                    const searchTerms = searchTerm.split(',').map(t => t.trim()).filter(t => t);
                    const matches = searchTerms.some(term => {
                        const matchesTag = exercise.tags && exercise.tags.some(tag => tag.toLowerCase().includes(term));
                        const matchesCategory = exercise.category.toLowerCase().includes(term);
                        const matchesTitle = exercise.title.toLowerCase().includes(term);
                        const matchesText = exercise.text.toLowerCase().includes(term);
                        return matchesTag || matchesCategory || matchesTitle || matchesText;
                    });
                    if (!matches) return;
                }
                filteredIndices.push(index);
            });
            // Atualizar contador de exerc√≠cios
            const counterElement = document.getElementById('exerciseCounter');
            if (counterElement) {
                counterElement.textContent = filteredIndices.length;
            }
            const totalPages = Math.ceil(filteredIndices.length / pageSize);
            if (currentPage > totalPages) currentPage = totalPages || 1;
            const startIndex = (currentPage - 1) * pageSize;
            const endIndex = startIndex + pageSize;
            const pageIndices = filteredIndices.slice(startIndex, endIndex);
            exerciseList.innerHTML = '';
            pageIndices.forEach(index => {
                const exercise = exercises[index];
                // ensure each exercise has an id (backwards compatibility)
                if (!exercise.id) {
                    exercise.id = 'ex-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,6);
                }
                const tagsHtml = exercise.tags && exercise.tags.length > 0 ? '<div class="tags">' + exercise.tags.map(tag => `<span class="tag">${tag}</span>`).join('') + '</div>' : '';
                const exerciseDiv = document.createElement('div');
                exerciseDiv.className = 'tweet';
                exerciseDiv.id = `exercise-${exercise.id}`;
                const timerData = timers[index] || { current: 0, history: [] };
                const timerDisplay = formatTime(timerData.current);
                const createdAtStr = exercise.createdAt ? formatDate(exercise.createdAt) : '';
                const nextReviewStr = exercise.nextReview ? formatDate(exercise.nextReview) : '';
                const recurringLabel = exercise.recurring ? (exercise.recurring === 'daily' ? 'Diariamente' : exercise.recurring === 'weekly' ? 'Semanalmente' : exercise.recurring === 'monthly' ? 'Mensalmente' : exercise.recurring) : '';
                const historyHtml = timerData.history && timerData.history.length > 0 
                    ? timerData.history.map((entry, i) => `<div class="history-entry"><div><span>#${i+1}:</span> ${entry.time} - ${new Date(entry.date).toLocaleString()}</div><button type="button" class="delete-time-btn" onclick="deleteTime(${index}, ${i})">√ó</button></div>`).join('')
                    : '<div class="no-history">Nenhum tempo registrado</div>';
                exerciseDiv.innerHTML = `
                    <div class="tweet-header">
                        <span class="difficulty ${exercise.difficulty}">${exercise.difficulty === 'easy' ? 'F√°cil' : exercise.difficulty === 'medium' ? 'M√©dio' : 'Dif√≠cil'}</span>
                        <span class="category">${exercise.category}</span>
                        <button class="annotation-btn ${exercise.annotations ? 'has-annotations' : ''}" onclick="openAnnotationModal(${index})">Anota√ß√µes</button>
                        <button class="favorite-btn" onclick="toggleFavorite(${index})">${exercise.favorite ? '‚òÖ' : '‚òÜ'}</button>
                    </div>
                    <div class="tweet-content">
                        <h4>${exercise.title}</h4>
                        ${tagsHtml}
                        <div class="exercise-meta"><small style="color:#666; display:block; margin-top:6px;">${createdAtStr ? 'Criado: ' + createdAtStr : ''}${nextReviewStr ? ' | Pr√≥xima revis√£o: ' + nextReviewStr + (recurringLabel ? ' ('+recurringLabel+')' : '') : ''}</small></div>
                        ${exercise.image ? `<img src="${exercise.image}" alt="Exerc√≠cio">` : ''}
                        <p>${renderTextWithInternalLinks(exercise.text || '')}</p>
                        ${exercise.audio ? `<audio controls src="${exercise.audio}" style="display:block; margin-top:8px; width:100%;">Seu navegador n√£o suporta o elemento de √°udio.</audio>` : ''}
                        <div class="timer-section collapsed">
                            <div class="timer-toggle">
                                <button class="timer-toggle-btn" onclick="toggleTimer(${index})">Expandir ‚ñº</button>
                            </div>
                            <div class="timer-display" id="timer-display-${index}">${timerDisplay}</div>
                            <div class="timer-controls">
                                <button class="timer-btn" id="timer-start-${index}" onclick="startTimer(${index})">Iniciar</button>
                                <button class="timer-btn pause" id="timer-pause-${index}" onclick="pauseTimer(${index})" style="display:none;">Pausar</button>
                                <button class="timer-btn reset" id="timer-reset-${index}" onclick="resetTimer(${index})">Reiniciar</button>
                                <button class="timer-btn complete" id="timer-complete-${index}" onclick="completeTimer(${index})">Completar</button>
                            </div>
                            <div class="timer-history">
                                <h5>Tempos Registrados:</h5>
                                ${historyHtml}
                            </div>
                        </div>
                        ${exercise.alternatives.length > 0 ? '<h5>Alternativas:</h5><form class="alt-form">' + exercise.alternatives.map((alt, i) => `<label class="alt-label"><button type="button" class="rasurar-btn" data-alt-index="${i}">‚úÇÔ∏è</button> <span class="alt-text">${alt}</span> <input type="radio" name="alt${index}" value="${i}"></label><br>`).join('') + '</form><button class="responder-btn" data-index="' + index + '">Responder</button> <button class="limpar-btn" data-index="' + index + '">Limpar</button>' : ''}
                        <div class="answer-accordion ${exercise.alternatives.length === 0 ? '' : 'hidden'}" id="accordion-${index}">
                            <button class="accordion-toggle">Mostrar Resolu√ß√£o</button>
                            <div class="accordion-content hidden">
                                ${exercise.answerImage || exercise.answerAudio ? `${exercise.answerImage ? `<img src="${exercise.answerImage}" alt="Resposta">` : ''}${exercise.answerAudio ? `<audio controls src="${exercise.answerAudio}" style="display:block; margin-top:8px; width:100%;">Seu navegador n√£o suporta o elemento de √°udio.</audio>` : ''}` : '<p>Sem imagem de resposta.</p>'}
                            </div>
                        </div>
                    </div>
                    <div class="menu-container"><button class="menu-btn" onclick="toggleMenu(${index})">‚ãÆ</button><div class="dropdown-menu hidden" id="menu-${index}"><button class="edit-btn" onclick="editExercise(${index})">Editar</button><br><button class="delete-btn" onclick="deleteExercise(${index})">Excluir</button><br><button class="info-btn" onclick="showInfo(${index})">Info.</button></div></div>
                    <div class="tweet-actions">
                        <button class="feito-btn ${exercise.status || 'not-done'}" onclick="toggleDone(${index})" title="${exercise.status === 'done' ? 'Conclu√≠do' : exercise.status === 'in-progress' ? 'Em Progresso' : 'N√£o Feito'}">${exercise.status === 'done' ? '‚úì Feito' : exercise.status === 'in-progress' ? '‚äô Incompleto' : 'N√£o Feito'}</button>
                    </div>
                `;
                exerciseList.appendChild(exerciseDiv);
                // Add listeners for buttons
                const responderBtn = exerciseDiv.querySelector('.responder-btn');
                const limparBtn = exerciseDiv.querySelector('.limpar-btn');
                if (responderBtn) {
                    responderBtn.addEventListener('click', () => {
                        const altForm = exerciseDiv.querySelector('.alt-form');
                        const selected = altForm.querySelector('input:checked');
                        if (selected) {
                            const selectedIndex = parseInt(selected.value);
                            const labels = altForm.querySelectorAll('label');
                            labels.forEach((label, i) => {
                                if (i === exercise.correctIndex) {
                                    label.style.color = 'green';
                                    label.style.fontWeight = 'bold';
                                } else if (i === selectedIndex) {
                                    label.style.color = 'red';
                                } else {
                                    label.style.color = '';
                                }
                            });
                            // Show accordion after answering
                            const accordion = exerciseDiv.querySelector(`#accordion-${index}`);
                            if (accordion) accordion.classList.remove('hidden');
                        }
                    });
                }
                if (limparBtn) {
                    limparBtn.addEventListener('click', () => {
                        const altForm = exerciseDiv.querySelector('.alt-form');
                        const radios = altForm.querySelectorAll('input[type="radio"]');
                        radios.forEach(radio => radio.checked = false);
                        const labels = altForm.querySelectorAll('label');
                        labels.forEach(label => {
                            label.style.color = '';
                            label.style.fontWeight = '';
                        });
                        const altTexts = altForm.querySelectorAll('.alt-text');
                        altTexts.forEach(text => text.classList.remove('rasurada'));
                        radios.forEach(radio => radio.disabled = false);
                        // Hide accordion on clear
                        const accordion = exerciseDiv.querySelector(`#accordion-${index}`);
                        if (accordion) accordion.classList.add('hidden');
                    });
                }
                // Rasurar buttons
                const rasurarBtns = exerciseDiv.querySelectorAll('.rasurar-btn');
                rasurarBtns.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        const altIndex = parseInt(btn.dataset.altIndex);
                        const label = btn.closest('.alt-label');
                        const altText = label.querySelector('.alt-text');
                        altText.classList.toggle('rasurada');
                        const radio = label.querySelector('input[type="radio"]');
                        radio.disabled = !radio.disabled;
                    });
                });
                // Accordion toggle
                const accordionToggle = exerciseDiv.querySelector('.accordion-toggle');
                if (accordionToggle) {
                    accordionToggle.addEventListener('click', () => {
                        const content = accordionToggle.nextElementSibling;
                        content.classList.toggle('hidden');
                    });
                }
            });
            renderPagination(totalPages);
            // Update tag list (keeps modal in sync)
            displayTags();
            // Refresh review indicator whenever exercises are rendered
            try { updateReviewIndicator(); } catch(e) { /* ignore if function not yet defined */ }
        }

        // Replace internal link syntax [[Title]] with anchor tags pointing to target exercise ids.
        function renderTextWithInternalLinks(text) {
            if (!text) return '';
            // Escape HTML basic
            const esc = (s) => (s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
            return text.replace(/\[\[([^\]]+)\]\]/g, (m, key) => {
                const title = key.trim();
                // find exercise by exact title (first match)
                const target = exercises.find(ex => ex.title && ex.title.toLowerCase() === title.toLowerCase());
                if (target && target.id) {
                    return `<a href="#" class="internal-link" data-target-id="${target.id}">${esc(title)}</a>`;
                }
                // not found ‚Äî render as plain escaped text
                return `[[${esc(title)}]]`;
            });
        }

        // Compute filtered indices according to current filters (same logic as displayExercises)
        function getFilteredIndices() {
            const filtered = [];
            exercises.forEach((exercise, index) => {
                if (currentCategory !== 'Todos' && exercise.category !== currentCategory) return;
                const exerciseStatus = exercise.status || 'not-done';
                if (currentStatus === 'done' && exerciseStatus !== 'done') return;
                if (currentStatus === 'not-done' && exerciseStatus !== 'not-done') return;
                if (currentStatus === 'in-progress' && exerciseStatus !== 'in-progress') return;
                if (currentStatus === 'favorites' && !exercise.favorite) return;
                if (searchTerm) {
                    const searchTerms = searchTerm.split(',').map(t => t.trim()).filter(t => t);
                    const matches = searchTerms.some(term => {
                        const matchesTag = exercise.tags && exercise.tags.some(tag => tag.toLowerCase().includes(term));
                        const matchesCategory = exercise.category.toLowerCase().includes(term);
                        const matchesTitle = exercise.title.toLowerCase().includes(term);
                        const matchesText = exercise.text.toLowerCase().includes(term);
                        return matchesTag || matchesCategory || matchesTitle || matchesText;
                    });
                    if (!matches) return;
                }
                filtered.push(index);
            });
            return filtered;
        }

        // Navigate to exercise by id: change filters/pages to reveal target, then scroll/highlight
        function navigateToExerciseById(id) {
            if (!id) return;
            const idx = exercises.findIndex(ex => ex.id === id);
            if (idx === -1) { alert('Exerc√≠cio alvo n√£o encontrado.'); return; }

            // Adjust filters to reveal the target: set category to the target's category, clear search and status filters
            const target = exercises[idx];
            currentCategory = target.category || 'Todos';
            currentStatus = 'all';
            searchTerm = '';

            // Recompute filtered indices and set page to target's page
            const filtered = getFilteredIndices();
            const pos = filtered.indexOf(idx);
            if (pos === -1) {
                // If not present even after adjusting category, fallback to opening edit modal
                editExercise(idx);
                return;
            }
            currentPage = Math.floor(pos / pageSize) + 1;
            // Render the new view
            showExercises();

            // After render, scroll and highlight
            setTimeout(() => {
                const el = document.getElementById(`exercise-${id}`);
                if (el) {
                    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    const old = el.style.background;
                    el.style.transition = 'background 0.6s ease';
                    el.style.background = '#fff3cd';
                    setTimeout(() => { el.style.background = old || ''; }, 1200);
                } else {
                    // If still not visible, open edit modal as last resort
                    editExercise(idx);
                }
            }, 60);
        }

        // Delegated handler for internal links
        document.getElementById('exerciseList').addEventListener('click', function(e) {
            const a = e.target.closest && e.target.closest('a.internal-link');
            if (a) {
                e.preventDefault();
                const tid = a.getAttribute('data-target-id');
                navigateToExerciseById(tid);
            }
        });

        function renderPagination(totalPages) {
            const paginationDiv = document.getElementById('pagination');
            paginationDiv.innerHTML = '';
            if (totalPages <= 1) return;
            // Previous button
            const prevBtn = document.createElement('button');
            prevBtn.textContent = 'Anterior';
            prevBtn.disabled = currentPage === 1;
            prevBtn.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    displayExercises();
                }
            });
            paginationDiv.appendChild(prevBtn);
            // Page numbers
            const maxVisible = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisible / 2));
            let endPage = Math.min(totalPages, startPage + maxVisible - 1);
            if (endPage - startPage + 1 < maxVisible) {
                startPage = Math.max(1, endPage - maxVisible + 1);
            }
            for (let i = startPage; i <= endPage; i++) {
                const pageBtn = document.createElement('button');
                pageBtn.textContent = i;
                if (i === currentPage) pageBtn.classList.add('active');
                pageBtn.addEventListener('click', () => {
                    currentPage = i;
                    displayExercises();
                });
                paginationDiv.appendChild(pageBtn);
            }
            // Next button
            const nextBtn = document.createElement('button');
            nextBtn.textContent = 'Pr√≥ximo';
            nextBtn.disabled = currentPage === totalPages;
            nextBtn.addEventListener('click', () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    displayExercises();
                }
            });
            paginationDiv.appendChild(nextBtn);
        }

        function toggleTimer(index) {
            let timerSection;
            
            // Check if we're in random mode
            if (isRandomMode) {
                timerSection = randomExerciseContent.querySelector('.timer-section');
            } else {
                timerSection = document.querySelector(`#exerciseList .tweet:nth-child(${index + 1}) .timer-section`);
            }
            
            if (!timerSection) return;
            
            const toggleBtn = timerSection.querySelector('.timer-toggle-btn');
            if (timerSection.classList.contains('collapsed')) {
                timerSection.classList.remove('collapsed');
                toggleBtn.textContent = 'Recolher ‚ñ≤';
            } else {
                timerSection.classList.add('collapsed');
                toggleBtn.textContent = 'Expandir ‚ñº';
            }
        }

        function formatTime(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${String(hrs).padStart(2, '0')}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function formatDate(iso) {
            if (!iso) return '';
            try {
                const d = new Date(iso);
                return d.toLocaleString();
            } catch (e) {
                return iso;
            }
        }

        function startTimer(index) {
            if (activeTimers[index]) return;
            const startBtn = document.getElementById(`timer-start-${index}`);
            const pauseBtn = document.getElementById(`timer-pause-${index}`);
            startBtn.style.display = 'none';
            pauseBtn.style.display = 'block';
            activeTimers[index] = setInterval(() => {
                if (!timers[index]) timers[index] = { current: 0, history: [] };
                timers[index].current++;
                document.getElementById(`timer-display-${index}`).textContent = formatTime(timers[index].current);
            }, 1000);
        }

        function pauseTimer(index) {
            if (!activeTimers[index]) return;
            clearInterval(activeTimers[index]);
            activeTimers[index] = null;
            const startBtn = document.getElementById(`timer-start-${index}`);
            const pauseBtn = document.getElementById(`timer-pause-${index}`);
            startBtn.style.display = 'block';
            pauseBtn.style.display = 'none';
        }

        function resetTimer(index) {
            if (activeTimers[index]) {
                clearInterval(activeTimers[index]);
                activeTimers[index] = null;
            }
            if (!timers[index]) timers[index] = { current: 0, history: [] };
            timers[index].current = 0;
            document.getElementById(`timer-display-${index}`).textContent = '00:00:00';
            const startBtn = document.getElementById(`timer-start-${index}`);
            const pauseBtn = document.getElementById(`timer-pause-${index}`);
            startBtn.style.display = 'block';
            pauseBtn.style.display = 'none';
        }

        function completeTimer(index) {
            if (activeTimers[index]) {
                clearInterval(activeTimers[index]);
                activeTimers[index] = null;
            }
            if (!timers[index]) timers[index] = { current: 0, history: [] };
            if (timers[index].current > 0) {
                const timeEntry = {
                    time: formatTime(timers[index].current),
                    date: new Date().toISOString()
                };
                timers[index].history.push(timeEntry);
                timers[index].current = 0;
                localStorage.setItem('timers', JSON.stringify(timers));
                // Update the appropriate view based on mode
                if (isRandomMode) {
                    displayRandomExercise();
                } else {
                    displayExercises();
                }
            }
        }

        function deleteTime(index, timeIndex) {
            if (confirm('Tem certeza que deseja excluir este tempo registrado?')) {
                if (!timers[index]) timers[index] = { current: 0, history: [] };
                timers[index].history.splice(timeIndex, 1);
                localStorage.setItem('timers', JSON.stringify(timers));
                // Update the appropriate view based on mode
                if (isRandomMode) {
                    displayRandomExercise();
                } else {
                    displayExercises();
                }
            }
        }

        function initializeSimuladoTimer(timerDiv, totalSeconds) {
            let remaining = totalSeconds;
            const display = timerDiv.querySelector('.timer-display');
            const startBtn = timerDiv.querySelector('.timer-btn.start');
            const pauseBtn = timerDiv.querySelector('.timer-btn.pause');
            const resetBtn = timerDiv.querySelector('.timer-btn.reset');
            const toggleBtn = timerDiv.querySelector('.timer-toggle-btn');
            let interval;

            function updateDisplay() {
                const mins = Math.floor(remaining / 60);
                const secs = remaining % 60;
                display.textContent = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            }

            updateDisplay();

            startBtn.addEventListener('click', () => {
                if (interval) return;
                interval = setInterval(() => {
                    remaining--;
                    updateDisplay();
                    if (remaining <= 0) {
                        clearInterval(interval);
                        alert('Tempo esgotado!');
                    }
                }, 1000);
                startBtn.style.display = 'none';
                pauseBtn.style.display = 'inline-block';
            });

            pauseBtn.addEventListener('click', () => {
                clearInterval(interval);
                interval = null;
                startBtn.style.display = 'inline-block';
                pauseBtn.style.display = 'none';
            });

            resetBtn.addEventListener('click', () => {
                clearInterval(interval);
                interval = null;
                remaining = totalSeconds;
                updateDisplay();
                startBtn.style.display = 'inline-block';
                pauseBtn.style.display = 'none';
            });

            toggleBtn.addEventListener('click', () => {
                timerDiv.classList.toggle('collapsed');
            });
        }

        async function deleteExercise(index) {
            console.log('üóëÔ∏è Tentando deletar exerc√≠cio no √≠ndice:', index);
            if (confirm('Tem certeza que deseja excluir este exerc√≠cio?')) {
                console.log('Exerc√≠cio antes da exclus√£o:', exercises[index]);
                console.log('Total de exerc√≠cios antes:', exercises.length);
                
                // Remove o exerc√≠cio
                exercises.splice(index, 1);
                
                // Remove o timer associado ao exerc√≠cio
                if (timers[index]) {
                    timers.splice(index, 1);
                }
                
                console.log('Total de exerc√≠cios depois:', exercises.length);
                console.log('Array de exerc√≠cios:', exercises);
                
                // Salva as altera√ß√µes usando saveToStorage (que salva em IndexedDB + localStorage)
                try {
                    await saveToStorage('exercises', exercises);
                    console.log('‚úÖ Exerc√≠cios salvos com sucesso');
                    console.log('LocalStorage exercises:', JSON.parse(localStorage.getItem('exercises')).length, 'itens');
                    
                    await saveToStorage('timers', timers);
                    console.log('‚úÖ Timers salvos com sucesso');
                } catch (error) {
                    console.error('‚ùå Erro ao salvar:', error);
                    alert('Erro ao deletar: ' + error);
                }
                
                // Pequeno delay para garantir que tudo foi salvo
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Atualiza a visualiza√ß√£o
                if (isRandomMode) {
                    closeRandomMode();
                    try { if (typeof updateReviewIndicator === 'function') updateReviewIndicator(); } catch(e) {}
                } else {
                    displayExercises();
                    try { if (typeof updateReviewIndicator === 'function') updateReviewIndicator(); } catch(e) {}
                }
            }
        }

        function displayTags() {
            if (!tagsList) return;
            tagsList.innerHTML = '';
            const allTags = exercises.flatMap(e => e.tags || []).map(t => t.trim()).filter(t => t);
            if (allTags.length === 0) {
                tagsList.innerHTML = '<div style="color:#666;">Nenhuma etiqueta encontrada.</div>';
                return;
            }
            const counts = allTags.reduce((acc, t) => { acc[t] = (acc[t] || 0) + 1; return acc; }, {});
            const unique = Object.keys(counts).sort((a,b) => counts[b] - counts[a] || a.localeCompare(b, 'pt-BR'));
            unique.forEach(tag => {
                const btn = document.createElement('button');
                btn.className = 'menu-btn';
                btn.style.padding = '6px 10px';
                btn.style.borderRadius = '6px';
                btn.style.display = 'flex';
                btn.style.alignItems = 'center';
                btn.style.gap = '8px';
                const label = document.createElement('span');
                label.textContent = tag;
                const badge = document.createElement('span');
                badge.textContent = counts[tag];
                badge.style.background = '#e9ecef';
                badge.style.padding = '2px 6px';
                badge.style.borderRadius = '999px';
                badge.style.fontSize = '12px';
                badge.style.color = '#000';
                btn.appendChild(label);
                btn.appendChild(badge);
                btn.addEventListener('click', () => {
                    searchInput.value = tag;
                    searchTerm = tag.toLowerCase();
                    currentPage = 1;
                    closeModalWindow(tagsModal);
                    showExercises();
                });
                tagsList.appendChild(btn);
            });
        }

        function showInfo(index) {
            const ex = exercises[index];
            alert(`Criado: ${new Date(ex.createdAt).toLocaleString()}\nAtualizado: ${new Date(ex.updatedAt).toLocaleString()}`);
        }

        function openAnnotationModal(index) {
            currentAnnotationIndex = index;
            annotationText.value = exercises[index].annotations;
            openModal(modal);
        }

        function toggleMenu(index) {
            const menu = document.getElementById(`menu-${index}`);
            const menuBtn = menu.previousElementSibling;
            if (menu.classList.contains('hidden')) {
                menu.classList.remove('hidden');
                const hideMenu = (e) => {
                    if (!menu.contains(e.target) && e.target !== menuBtn) {
                        menu.classList.add('hidden');
                        document.removeEventListener('click', hideMenu);
                    }
                };
                setTimeout(() => document.addEventListener('click', hideMenu), 0);
            } else {
                menu.classList.add('hidden');
            }
        }

        function toggleFavorite(index) {
            exercises[index].favorite = !exercises[index].favorite;
            localStorage.setItem('exercises', JSON.stringify(exercises));
            if (isRandomMode) {
                displayRandomExercise();
            } else {
                displayExercises();
            }
        }

        function toggleDone(index) {
            // Cycle through states: not-done -> in-progress -> done -> not-done
            const currentStatus = exercises[index].status || 'not-done';
            let newStatus = 'not-done';
            if (currentStatus === 'not-done') {
                newStatus = 'in-progress';
            } else if (currentStatus === 'in-progress') {
                newStatus = 'done';
            } else if (currentStatus === 'done') {
                newStatus = 'not-done';
            }
            exercises[index].status = newStatus;
            // Keep done for backwards compatibility with stats
            exercises[index].done = (newStatus === 'done');
            exercises[index].updatedAt = new Date().toISOString();
            localStorage.setItem('exercises', JSON.stringify(exercises));
            if (isRandomMode) {
                displayRandomExercise();
            } else {
                displayExercises();
            }
        }

        function openStatsModal() {
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('statsDate').value = today;
            const dayStats = stats[today] || { done: 0, correct: 0, wrong: 0, goal: 0 };
            document.getElementById('statsDone').value = dayStats.done;
            document.getElementById('statsCorrect').value = dayStats.correct;
            document.getElementById('statsWrong').value = dayStats.wrong;
            document.getElementById('statsGoal').value = dayStats.goal;
            openModal(statsModal);
        }

        function showExercises() {
            currentView = 'exercises';
            newExerciseBtn.style.display = '';
            exerciseList.style.display = 'block';
            statsSection.style.display = 'none';
            simuladoSection.style.display = 'none';
            document.getElementById('statsBtn').classList.remove('active');
            simuladoBtn.classList.remove('active');
            displayExercises();
        }

        function showStats() {
            currentView = 'stats';
            newExerciseBtn.style.display = '';
            exerciseList.style.display = 'none';
            statsSection.style.display = 'block';
            simuladoSection.style.display = 'none';
            document.getElementById('statsBtn').classList.add('active');
            simuladoBtn.classList.remove('active');
            displayStats();
        }

        function displayStats() {
            statsList.innerHTML = '';
            const sortedDates = Object.keys(stats).sort((a, b) => new Date(b) - new Date(a));
            sortedDates.forEach(date => {
                const dayStats = stats[date];
                const [year, month, day] = date.split('-');
                const formattedDate = `${day}/${month}/${year}`;
                const div = document.createElement('div');
                div.className = 'stats-entry';
                div.innerHTML = `
                    <h3>${formattedDate}</h3>
                    <p>Quest√µes Feitas: ${dayStats.done}</p>
                    <p>Acertos: ${dayStats.correct}</p>
                    <p>Erros: ${dayStats.wrong}</p>
                    <p>Meta: ${dayStats.goal}</p>
                    <button onclick="editStats('${date}')">Editar</button>
                    <button onclick="deleteStats('${date}')">Excluir</button>
                `;
                statsList.appendChild(div);
            });
        }

        function showSimulado() {
            currentView = 'simulado';
            newExerciseBtn.style.display = 'none';
            exerciseList.style.display = 'none';
            statsSection.style.display = 'none';
            simuladoSection.style.display = 'block';
            document.getElementById('statsBtn').classList.remove('active');
            simuladoBtn.classList.add('active');
            displaySimuladoStats();
            displaySimuladoHistory();
            simuladoList.innerHTML = '';
            submitSimulado.style.display = 'none';
        }

        function displaySimuladoStats() {
            const total = simuladoHistory.length;
            const mediaAcertos = total > 0 ? (simuladoHistory.reduce((sum, s) => sum + (s.correct / s.total * 100), 0) / total).toFixed(1) : 0;
            const tempoMedio = total > 0 ? (simuladoHistory.reduce((sum, s) => sum + s.time, 0) / total).toFixed(1) : 0;
            document.getElementById('totalSimulados').textContent = total;
            document.getElementById('mediaAcertos').textContent = mediaAcertos + '%';
            document.getElementById('tempoMedio').textContent = tempoMedio + ' min';
        }

        function displaySimuladoHistory() {
            historyList.innerHTML = '';
            simuladoHistory.slice(-10).reverse().forEach((simulado, index) => {
                const div = document.createElement('div');
                div.className = 'history-entry';
                const date = new Date(simulado.date).toLocaleDateString('pt-BR');
                const percentage = ((simulado.correct / simulado.total) * 100).toFixed(1);
                div.innerHTML = `
                    <span>${date}: ${simulado.correct}/${simulado.total} (${percentage}%) - ${simulado.time} min</span>
                    <button class="delete-simulado-btn" onclick="deleteSimulado(${simuladoHistory.length - 1 - index})">Excluir</button>
                `;
                historyList.appendChild(div);
            });
        }

        function deleteSimulado(index) {
            if (confirm('Tem certeza que deseja excluir este simulado do hist√≥rico?')) {
                simuladoHistory.splice(index, 1);
                localStorage.setItem('simuladoHistory', JSON.stringify(simuladoHistory));
                displaySimuladoStats();
                displaySimuladoHistory();
            }
        }

        function startNewSimulado() {
            const time = parseInt(document.getElementById('simuladoTime').value);
            const numQuestions = parseInt(document.getElementById('numQuestions').value);
            const selectedDifficulties = [];
            if (document.getElementById('difficultyEasy').checked) selectedDifficulties.push('easy');
            if (document.getElementById('difficultyMedium').checked) selectedDifficulties.push('medium');
            if (document.getElementById('difficultyHard').checked) selectedDifficulties.push('hard');

            const selectedCategories = [];
            if (document.getElementById('categoryProducao').checked) selectedCategories.push('Produ√ß√£o Textual');
            if (document.getElementById('categoryGramatica').checked) selectedCategories.push('Gram√°tica Pura');
            if (document.getElementById('categoryToefl').checked) selectedCategories.push('Preparat√≥rio TOEFL');
            const tags = document.getElementById('simuladoTag').value.trim().split(',').map(t => t.trim()).filter(t => t);
            const status = document.getElementById('simuladoStatus') ? document.getElementById('simuladoStatus').value : 'all';
            closeModalWindow(simuladoModal);
            generateSimulado({ time, numQuestions, selectedDifficulties, selectedCategories, tags, status });
        }

        function generateSimulado(options) {
            let eligible = exercises.filter(ex => ex.alternatives && ex.alternatives.length > 0);
            if (options.selectedDifficulties.length > 0) {
                eligible = eligible.filter(ex => options.selectedDifficulties.includes(ex.difficulty));
            }
            if (options.selectedCategories.length > 0) {
                eligible = eligible.filter(ex => options.selectedCategories.includes(ex.category));
            }
            // Filter by completion status if requested
            if (options.status === 'done') {
                eligible = eligible.filter(ex => ex.done === true);
            } else if (options.status === 'not-done') {
                eligible = eligible.filter(ex => !ex.done);
            }
            if (options.tags && options.tags.length > 0) {
                eligible = eligible.filter(ex => ex.tags && options.tags.some(tag => ex.tags.some(t => t.toLowerCase().includes(tag.toLowerCase()))));
            }
            if (eligible.length < options.numQuestions) {
                alert(`N√£o h√° quest√µes suficientes (${eligible.length}) para gerar um simulado de ${options.numQuestions} quest√µes.`);
                return;
            }
            const shuffled = eligible.sort(() => 0.5 - Math.random());
            const selected = shuffled.slice(0, options.numQuestions);
            window.selectedExercises = selected;
            window.simuladoOptions = options;
            window.startTime = Date.now();
            simuladoList.innerHTML = '';
            if (options.time > 0) {
                const timerDiv = document.createElement('div');
                timerDiv.className = 'timer-section';
                timerDiv.innerHTML = `
                    <div class="timer-toggle">
                        <button class="timer-toggle-btn">‚è±Ô∏è Cron√¥metro</button>
                    </div>
                    <div class="timer-controls">
                        <button class="timer-btn start">Iniciar</button>
                        <button class="timer-btn pause">Pausar</button>
                        <button class="timer-btn reset">Resetar</button>
                    </div>
                    <div class="timer-display">00:00</div>
                    <div class="timer-history"></div>
                `;
                simuladoList.appendChild(timerDiv);
                // Initialize timer
                initializeSimuladoTimer(timerDiv, options.time * 60);
            }
            selected.forEach((ex, i) => {
                const div = document.createElement('div');
                div.className = 'simulado-question';
                div.innerHTML = `
                    <h4>${i+1}. ${ex.title}</h4>
                    ${ex.tags ? '<div class="tags">' + ex.tags.map(tag => `<span class="tag">${tag}</span>`).join('') + '</div>' : ''}
                    ${ex.image ? `<img src="${ex.image}" alt="Exerc√≠cio">` : ''}
                    <p>${ex.text}</p>
                    <form class="alt-form">
                        ${ex.alternatives.map((alt, j) => `<label class="alt-label"><input type="radio" name="q${i}" value="${j}"> ${alt}</label><br>`).join('')}
                    </form>
                `;
                simuladoList.appendChild(div);
            });
            submitSimulado.style.display = 'block';
            // Start timer if time > 0
            if (options.time > 0) {
                startTimer(options.time * 60); // convert to seconds
            }
        }

        function deleteStats(date) {
            if (confirm('Tem certeza que deseja excluir as estat√≠sticas desta data?')) {
                delete stats[date];
                localStorage.setItem('stats', JSON.stringify(stats));
                displayStats();
            }
        }

        function editStats(date) {
            document.getElementById('statsDate').value = date;
            const dayStats = stats[date];
            document.getElementById('statsDone').value = dayStats.done;
            document.getElementById('statsCorrect').value = dayStats.correct;
            document.getElementById('statsWrong').value = dayStats.wrong;
            document.getElementById('statsGoal').value = dayStats.goal;
            statsModal.style.display = 'block';
        }

        closeModal.onclick = () => closeModalWindow(modal);

        closeNewModal.onclick = () => clearNewExerciseModal();

        closeEditModal.onclick = () => closeModalWindow(editModal);

        closeStatsModal.onclick = () => closeModalWindow(statsModal);

        saveAnnotation.onclick = function() {
            exercises[currentAnnotationIndex].annotations = annotationText.value;
            exercises[currentAnnotationIndex].updatedAt = new Date().toISOString();
            localStorage.setItem('exercises', JSON.stringify(exercises));
            if (isRandomMode) {
                displayRandomExercise();
            } else {
                displayExercises();
            }
            closeModalWindow(modal);
        };

        closeStatsModal.onclick = function() {
            statsModal.style.display = 'none';
        };

        saveStats.onclick = function() {
            const date = document.getElementById('statsDate').value;
            const done = parseInt(document.getElementById('statsDone').value) || 0;
            const correct = parseInt(document.getElementById('statsCorrect').value) || 0;
            const wrong = parseInt(document.getElementById('statsWrong').value) || 0;
            const goal = parseInt(document.getElementById('statsGoal').value) || 0;
            stats[date] = { done, correct, wrong, goal };
            localStorage.setItem('stats', JSON.stringify(stats));
            if (currentView === 'stats') displayStats();
            closeModalWindow(statsModal);
        };

        submitSimulado.onclick = function() {
            const questions = simuladoList.querySelectorAll('.simulado-question');
            let correct = 0;
            const userAnswers = [];
            questions.forEach((q, i) => {
                const selected = q.querySelector('input:checked');
                const selectedIndex = selected ? parseInt(selected.value) : -1;
                userAnswers.push(selectedIndex);
                if (selectedIndex === window.selectedExercises[i].correctIndex) {
                    correct++;
                }
            });
            const total = questions.length;
            const timeSpent = Math.round((Date.now() - window.startTime) / 60000);
            const result = {
                date: new Date().toISOString(),
                correct,
                total,
                time: timeSpent
            };
            simuladoHistory.push(result);
            localStorage.setItem('simuladoHistory', JSON.stringify(simuladoHistory));
            displaySimuladoStats();
            displaySimuladoHistory();

            // Show results
            showSimuladoResults(userAnswers);
        };

        function showSimuladoResults(userAnswers) {
            simuladoList.innerHTML = '<h3>Resultado do Simulado</h3>';
            window.selectedExercises.forEach((ex, i) => {
                const userChoice = userAnswers[i];
                const isCorrect = userChoice === ex.correctIndex;
                const div = document.createElement('div');
                div.className = `simulado-question ${isCorrect ? 'correct' : 'incorrect'}`;
                div.innerHTML = `
                    <h4>${i+1}. ${ex.title} ${isCorrect ? '‚úÖ' : '‚ùå'}</h4>
                    ${ex.tags ? '<div class="tags">' + ex.tags.map(tag => `<span class="tag">${tag}</span>`).join('') + '</div>' : ''}
                    ${ex.image ? `<img src="${ex.image}" alt="Exerc√≠cio">` : ''}
                    <p>${ex.text}</p>
                    <div class="result-alternatives">
                        ${ex.alternatives.map((alt, j) => {
                            let className = '';
                            if (j === ex.correctIndex) className = 'correct-answer';
                            else if (j === userChoice) className = 'wrong-answer';
                            return `<div class="alt-result ${className}">${alt}</div>`;
                        }).join('')}
                    </div>
                `;
                simuladoList.appendChild(div);
            });
            submitSimulado.style.display = 'none';
            // Add a button to go back
            const backBtn = document.createElement('button');
            backBtn.textContent = 'Voltar ao Simulado';
            backBtn.onclick = () => showSimulado();
            simuladoList.appendChild(backBtn);
        }

        saveEdit.onclick = function() {
            let title = document.getElementById('editTitle').value.trim();
            const difficulty = document.getElementById('editDifficulty').value;
            const category = document.getElementById('editCategory').value;
            const imageInput = document.getElementById('editImage');
            const editAnswerImageInput = document.getElementById('editAnswerImage');
            const editAudioInputLocal = document.getElementById('editAudio');
            const editAnswerAudioInputLocal = document.getElementById('editAnswerAudio');
            const exerciseText = document.getElementById('editExerciseText').value;
            const tagsInput = document.getElementById('editTags').value;
            const tags = tagsInput ? tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag.startsWith('#')) : [];
            const editReviewFlag = document.getElementById('editReviewFlag') ? document.getElementById('editReviewFlag').checked : false;
            const editRecurrenceSel = document.getElementById('editRecurrence');
            const editRecurrence = editRecurrenceSel ? editRecurrenceSel.value || null : null;
            const editNextDate = document.getElementById('editNextReviewDate');
            const editNextReview = editNextDate && editNextDate.value ? new Date(editNextDate.value + 'T00:00:00').toISOString() : null;
            const alternatives = Array.from(editAlternativesContainer.querySelectorAll('input')).map(input => input.value.trim()).filter(val => val);
            const correctIndex = alternatives.length > 0 ? parseInt(document.getElementById('editCorrectAlt').value) || 0 : null;

            // If no title provided, use image filename
            if (!title && imageInput.files[0]) {
                title = imageInput.files[0].name.replace(/\.[^/.]+$/, ''); // Remove file extension
            }

            if (!difficulty || !category) {
                alert('T√≠tulo, dificuldade e categoria s√£o obrigat√≥rios.');
                return;
            }

            let imageData = exercises[editingIndex].image;
            let answerImageData = exercises[editingIndex].answerImage;
            let editAudioData = exercises[editingIndex].audio || null;
            let editAnswerAudioData = exercises[editingIndex].answerAudio || null;
            let filesToRead = 0;
            if (imageInput.files[0]) filesToRead++;
            if (editAnswerImageInput.files[0]) filesToRead++;
            if (editAudioInputLocal && editAudioInputLocal.files[0]) filesToRead++;
            if (editAnswerAudioInputLocal && editAnswerAudioInputLocal.files[0]) filesToRead++;

                if (filesToRead === 0) {
                saveEditExercise(title, difficulty, category, imageData, exerciseText, answerImageData, alternatives, correctIndex, tags, editReviewFlag, editAudioData, editAnswerAudioData, editNextReview, editRecurrence);
            } else {
                if (imageInput.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        imageData = event.target.result;
                        filesToRead--;
                        if (filesToRead === 0) saveEditExercise(title, difficulty, category, imageData, exerciseText, answerImageData, alternatives, correctIndex, tags, editReviewFlag, editAudioData, editAnswerAudioData, editNextReview, editRecurrence);
                    };
                    reader.readAsDataURL(imageInput.files[0]);
                }
                if (editAnswerImageInput.files[0]) {
                    const reader2 = new FileReader();
                    reader2.onload = function(event) {
                        answerImageData = event.target.result;
                        filesToRead--;
                        if (filesToRead === 0) saveEditExercise(title, difficulty, category, imageData, exerciseText, answerImageData, alternatives, correctIndex, tags, editReviewFlag, editAudioData, editAnswerAudioData, editNextReview, editRecurrence);
                    };
                    reader2.readAsDataURL(editAnswerImageInput.files[0]);
                }
                if (editAudioInputLocal && editAudioInputLocal.files[0]) {
                    const r3 = new FileReader();
                    r3.onload = function(ev) {
                        editAudioData = ev.target.result;
                        filesToRead--;
                        if (filesToRead === 0) saveEditExercise(title, difficulty, category, imageData, exerciseText, answerImageData, alternatives, correctIndex, tags, editReviewFlag, editAudioData, editAnswerAudioData, editNextReview, editRecurrence);
                    };
                    r3.readAsDataURL(editAudioInputLocal.files[0]);
                }
                if (editAnswerAudioInputLocal && editAnswerAudioInputLocal.files[0]) {
                    const r4 = new FileReader();
                    r4.onload = function(ev) {
                        editAnswerAudioData = ev.target.result;
                        filesToRead--;
                        if (filesToRead === 0) saveEditExercise(title, difficulty, category, imageData, exerciseText, answerImageData, alternatives, correctIndex, tags, editReviewFlag, editAudioData, editAnswerAudioData);
                    };
                    r4.readAsDataURL(editAnswerAudioInputLocal.files[0]);
                }
            }
        };

        function saveEditExercise(title, difficulty, category, imageData, exerciseText, answerImageData, alternatives, correctIndex, tags = [], review = false, audioData = null, answerAudioData = null, nextReview = null, recurring = null) {
            const existing = exercises[editingIndex] || {};
            exercises[editingIndex] = {
                id: existing.id || ('ex-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,6)),
                title,
                difficulty,
                category,
                image: imageData,
                text: exerciseText,
                answerImage: answerImageData,
            audio: audioData,
            answerAudio: answerAudioData,
            review: !!review,
            nextReview: nextReview || existing.nextReview || null,
            recurring: recurring || existing.recurring || null,
                alternatives,
                correctIndex,
                annotations: existing.annotations,
                tags,
                status: existing.status || 'not-done',
                done: existing.done,
                favorite: existing.favorite,
                createdAt: existing.createdAt || new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };
            editingIndex = null;
            localStorage.setItem('exercises', JSON.stringify(exercises));
            if (isRandomMode) {
                displayRandomExercise();
            } else {
                displayExercises();
            }
            closeModalWindow(editModal);
        };

        function editExercise(index) {
            editingIndex = index;
            const ex = exercises[index];
            document.getElementById('editTitle').value = ex.title;
            document.getElementById('editDifficulty').value = ex.difficulty;
            document.getElementById('editCategory').value = ex.category;
            document.getElementById('editExerciseText').value = ex.text || '';
            document.getElementById('editNewTagInput').value = '';
            // Clear previous alternatives
            editAlternativesContainer.innerHTML = '';
            if (ex.alternatives && ex.alternatives.length > 0) {
                ex.alternatives.forEach((alt, i) => addEditAlternativeInput(alt));
            }
            updateEditCorrectAltOptions();
            document.getElementById('editCorrectAlt').value = ex.correctIndex || 0;
            // Populate audio preview if available
            const editAudioPreview = document.getElementById('editAudioPreview');
            const editAnswerAudioPreview = document.getElementById('editAnswerAudioPreview');
            if (editAudioPreview) {
                editAudioPreview.innerHTML = ex.audio ? `<audio controls src="${ex.audio}" style="display:block; width:100%;">Seu navegador n√£o suporta o elemento de √°udio.</audio>` : '';
            }
            if (editAnswerAudioPreview) {
                editAnswerAudioPreview.innerHTML = ex.answerAudio ? `<audio controls src="${ex.answerAudio}" style="display:block; width:100%;">Seu navegador n√£o suporta o elemento de √°udio.</audio>` : '';
            }
            // Populate recurrence fields
            const editRecurrenceSel = document.getElementById('editRecurrence');
            if (editRecurrenceSel) editRecurrenceSel.value = ex.recurring || '';
            const editNextDate = document.getElementById('editNextReviewDate');
            if (editNextDate) editNextDate.value = ex.nextReview ? (new Date(ex.nextReview)).toISOString().slice(0,10) : '';
            openModal(editModal);
            // Inicializa o seletor de tags para edi√ß√£o
            initializeTagSelector('editExistingTags', 'editSelectedTagsDisplay', 'editNewTagInput', 'editTags', 'edit');
        }

        // Paste image
        document.getElementById('image').addEventListener('paste', handlePaste);
        document.getElementById('editImage').addEventListener('paste', handlePaste);
        document.getElementById('answerImage').addEventListener('paste', handlePaste);
        document.getElementById('editAnswerImage').addEventListener('paste', handlePaste);

        function handlePaste(e) {
            const items = e.clipboardData.items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    e.preventDefault();
                    const file = items[i].getAsFile();
                    const dt = new DataTransfer();
                    dt.items.add(file);
                    e.target.files = dt.files;
                }
            }
        }

        function exportData() {
            const data = {
                exercises,
                stats,
                timers,
                simuladoHistory
            };
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dados_exercicios.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importData(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    if (data.exercises) exercises = data.exercises;
                    if (data.stats) stats = data.stats;
                    if (data.timers) timers = data.timers;
                    if (data.simuladoHistory) simuladoHistory = data.simuladoHistory;
                    localStorage.setItem('exercises', JSON.stringify(exercises));
                    localStorage.setItem('stats', JSON.stringify(stats));
                    localStorage.setItem('timers', JSON.stringify(timers));
                    localStorage.setItem('simuladoHistory', JSON.stringify(simuladoHistory));
                    displayExercises();
                    if (currentView === 'stats') displayStats();
                    if (currentView === 'simulado') {
                        displaySimuladoStats();
                        displaySimuladoHistory();
                    }
                    alert('Dados importados com sucesso!');
                } catch (error) {
                    alert('Erro ao importar dados: ' + error.message);
                }
            };
            reader.readAsText(file);
        }
        
        const hamburgerBtn = document.getElementById('hamburgerBtn');
        const leftSidebar = document.getElementById('leftSidebar');
        const modalOverlay = document.getElementById('modalOverlay');

        hamburgerBtn.addEventListener('click', () => {
            leftSidebar.classList.toggle('active');
            modalOverlay.classList.toggle('active');
        });

        modalOverlay.addEventListener('click', () => {
            leftSidebar.classList.remove('active');
            modalOverlay.classList.remove('active');
        });

        document.querySelectorAll('.category-btn, .stats-btn, .simulado-btn, #tagsBtn, #exportBtn, #importBtn, #storageBtn').forEach(btn => {
            btn.addEventListener('click', () => {
                leftSidebar.classList.remove('active');
                modalOverlay.classList.remove('active');
            });
        });

        randomModeBtn.addEventListener('click', () => {
            if (isRandomMode) {
                closeRandomMode();
            } else {
                startRandomMode();
            }
        });

        closeRandomBtn.addEventListener('click', closeRandomMode);

        prevRandomBtn.addEventListener('click', () => {
            if (!randomExercises || randomExercises.length === 0) return;
            const current = randomExercises[currentRandomIndex];
            if (isReviewMode && current && current.type === 'flashcard-batch') {
                if (current.batchCursor > 0) {
                    current.batchCursor--;
                    displayRandomExercise();
                    return;
                }
            }
            if (currentRandomIndex > 0) {
                currentRandomIndex--;
                displayRandomExercise();
            }
        });

        nextRandomBtn.addEventListener('click', () => {
            if (!randomExercises || randomExercises.length === 0) return;
            const current = randomExercises[currentRandomIndex];
            if (isReviewMode && current && current.type === 'flashcard-batch') {
                if (current.batchCursor < (current.indices.length - 1)) {
                    current.batchCursor++;
                    displayRandomExercise();
                    return;
                }
            }
            if (currentRandomIndex < randomExercises.length - 1) {
                currentRandomIndex++;
                displayRandomExercise();
            }
        });

        function startRandomMode() {
            // Get exercises based on current category and status
            let filtered = exercises.filter(exercise => {
                if (currentCategory !== 'Todos' && exercise.category !== currentCategory) return false;
                const exerciseStatus = exercise.status || 'not-done';
                if (currentStatus === 'done' && exerciseStatus !== 'done') return false;
                if (currentStatus === 'not-done' && exerciseStatus !== 'not-done') return false;
                if (currentStatus === 'in-progress' && exerciseStatus !== 'in-progress') return false;
                if (currentStatus === 'favorites' && !exercise.favorite) return false;
                return true;
            });

            if (filtered.length === 0) {
                alert(`Nenhum exerc√≠cio encontrado em "${currentCategory}" com o status "${currentStatus}".`);
                return;
            }

            // Shuffle the exercises
            randomExercises = filtered.sort(() => 0.5 - Math.random());
            currentRandomIndex = 0;
            isRandomMode = true;
            randomModeBtn.classList.add('active');
            randomExerciseContainer.classList.add('show');
            exerciseList.style.display = 'none';
            document.getElementById('pagination').style.display = 'none';
            displayRandomExercise();
        }

        function closeRandomMode() {
            isRandomMode = false;
            randomModeBtn.classList.remove('active');
            randomExerciseContainer.classList.remove('show');
            // if we were in review mode, turn it off and hide the review button
            isReviewMode = false;
            if (reviewOkBtn) reviewOkBtn.style.display = 'none';
            exerciseList.style.display = 'block';
            document.getElementById('pagination').style.display = 'flex';
            displayExercises();
        }

        function displayRandomExercise() {
            if (randomExercises.length === 0) return;
            const item = randomExercises[currentRandomIndex];
            // if this is a flashcard-type item, render differently
            if (item && item.type === 'flashcard-batch') {
                const batch = flashcardBatches.find(b => b.id === item.batchId);
                const idxInBatch = item.indices[item.batchCursor];
                const card = batch && batch.cards && batch.cards[idxInBatch] ? batch.cards[idxInBatch] : null;
                const total = item.indices.length;
                const pos = item.batchCursor + 1;
                randomExerciseContent.innerHTML = `
                <div class="tweet" style="margin: 0;">
                    <div class="tweet-header">
                        <span class="category">Flashcards ‚Äî ${item.batchName || ''}</span>
                        <span style="margin-left:8px; font-size:12px; color:#666;">${pos}/${total}</span>
                    </div>
                    <div class="tweet-content" style="display:flex; flex-direction:column; gap:8px;">
                        <div style="font-size:18px; font-weight:600;">${(card && card.front||'').replace(/</g,'&lt;')}</div>
                        ${card && card.audioFront ? `<audio controls src="${card.audioFront}" style="display:block; margin-top:8px; width:100%;"></audio>` : ''}
                        <div><button class="accordion-toggle">Mostrar Verso</button>
                            <div class="accordion-content hidden" style="margin-top:8px;">
                                <div style="font-size:16px;">${(card && card.back||'').replace(/</g,'&lt;')}</div>
                                ${card && card.audioBack ? `<audio controls src="${card.audioBack}" style="display:block; margin-top:6px; width:100%;"></audio>` : ''}
                            </div>
                        </div>
                    </div>
                </div>`;
                const accordionToggle = randomExerciseContent.querySelector('.accordion-toggle');
                if (accordionToggle) {
                    accordionToggle.addEventListener('click', () => {
                        const content = accordionToggle.nextElementSibling;
                        content.classList.toggle('hidden');
                    });
                }
                prevRandomBtn.disabled = !(currentRandomIndex > 0 || item.batchCursor > 0);
                nextRandomBtn.disabled = !(currentRandomIndex < randomExercises.length - 1 || item.batchCursor < (item.indices.length - 1));
                randomCounter.textContent = `${currentRandomIndex + 1}/${randomExercises.length}`;
                tryResumePendingAudio();
                return;
            }

            const exercise = item;
            const index = exercises.findIndex(ex => ex.id === (exercise && exercise.id));
            const tagsHtml = exercise.tags && exercise.tags.length > 0 
                ? '<div class="tags">' + exercise.tags.map(tag => `<span class="tag">${tag}</span>`).join('') + '</div>' 
                : '';
            
            const timerData = timers[index] || { current: 0, history: [] };
            const timerDisplay = formatTime(timerData.current);
            const historyHtml = timerData.history && timerData.history.length > 0 
                ? timerData.history.map((entry, i) => `<div class="history-entry"><div><span>#${i+1}:</span> ${entry.time} - ${new Date(entry.date).toLocaleString()}</div><button type="button" class="delete-time-btn" onclick="deleteTime(${index}, ${i})">√ó</button></div>`).join('')
                : '<div class="no-history">Nenhum tempo registrado</div>';

            randomExerciseContent.innerHTML = `
                <div class="tweet" style="margin: 0;">
                    <div class="tweet-header">
                        <span class="difficulty ${exercise.difficulty}">${exercise.difficulty === 'easy' ? 'F√°cil' : exercise.difficulty === 'medium' ? 'M√©dio' : 'Dif√≠cil'}</span>
                        <span class="category">${exercise.category}</span>
                        <button class="annotation-btn ${exercise.annotations ? 'has-annotations' : ''}" onclick="openAnnotationModal(${index})">Anota√ß√µes</button>
                        <button class="favorite-btn" onclick="toggleFavorite(${index})">${exercise.favorite ? '‚òÖ' : '‚òÜ'}</button>
                    </div>
                    <div class="tweet-content">
                        <h4>${exercise.title}</h4>
                        ${tagsHtml}
                        ${exercise.image ? `<img src="${exercise.image}" alt="Exerc√≠cio">` : ''}
                        <p>${exercise.text}</p>
                        ${exercise.audio ? `<audio controls src="${exercise.audio}" style="display:block; margin-top:8px; width:100%;">Seu navegador n√£o suporta o elemento de √°udio.</audio>` : ''}
                        <div class="timer-section collapsed">
                            <div class="timer-toggle">
                                <button class="timer-toggle-btn" onclick="toggleTimer(${index})">Expandir ‚ñº</button>
                            </div>
                            <div class="timer-display" id="timer-display-${index}">${timerDisplay}</div>
                            <div class="timer-controls">
                                <button class="timer-btn" id="timer-start-${index}" onclick="startTimer(${index})">Iniciar</button>
                                <button class="timer-btn pause" id="timer-pause-${index}" onclick="pauseTimer(${index})" style="display:none;">Pausar</button>
                                <button class="timer-btn reset" id="timer-reset-${index}" onclick="resetTimer(${index})">Reiniciar</button>
                                <button class="timer-btn complete" id="timer-complete-${index}" onclick="completeTimer(${index})">Completar</button>
                            </div>
                            <div class="timer-history">
                                <h5>Tempos Registrados:</h5>
                                ${historyHtml}
                            </div>
                        </div>
                        ${exercise.alternatives.length > 0 ? '<h5>Alternativas:</h5><form class="alt-form">' + exercise.alternatives.map((alt, i) => `<label class="alt-label"><button type="button" class="rasurar-btn" data-alt-index="${i}">‚úÇÔ∏è</button> <span class="alt-text">${alt}</span> <input type="radio" name="alt${index}" value="${i}"></label><br>`).join('') + '</form><button class="responder-btn" data-index="' + index + '">Responder</button> <button class="limpar-btn" data-index="' + index + '">Limpar</button>' : ''}
                        <div class="answer-accordion ${exercise.alternatives.length === 0 ? '' : 'hidden'}" id="accordion-${index}">
                            <button class="accordion-toggle">Mostrar Resolu√ß√£o</button>
                            <div class="accordion-content hidden">
                                ${exercise.answerImage ? `<img src="${exercise.answerImage}" alt="Resposta">` : ''}
                                ${exercise.answerAudio ? `<audio controls src="${exercise.answerAudio}" style="display:block; margin-top:8px; width:100%;">Seu navegador n√£o suporta o elemento de √°udio.</audio>` : (exercise.answerImage ? '' : '<p>Sem imagem de resposta.</p>')}
                            </div>
                        </div>
                    </div>
                    <div class="menu-container"><button class="menu-btn" onclick="toggleMenu(${index})">‚ãÆ</button><div class="dropdown-menu hidden" id="menu-${index}"><button class="edit-btn" onclick="editExercise(${index})">Editar</button><br><button class="delete-btn" onclick="deleteExercise(${index})">Excluir</button><br><button class="info-btn" onclick="showInfo(${index})">Info.</button></div></div>
                    <div class="tweet-actions">
                        <button class="feito-btn ${exercise.status || 'not-done'}" onclick="toggleDone(${index})" title="${exercise.status === 'done' ? 'Conclu√≠do' : exercise.status === 'in-progress' ? 'Em Progresso' : 'N√£o Feito'}">${exercise.status === 'done' ? '‚úì Feito' : exercise.status === 'in-progress' ? '‚äô Incompleto' : 'N√£o Feito'}</button>
                    </div>
                </div>
            `;

            // Add event listeners for the random exercise
            const responderBtn = randomExerciseContent.querySelector('.responder-btn');
            const limparBtn = randomExerciseContent.querySelector('.limpar-btn');
            if (responderBtn) {
                responderBtn.addEventListener('click', () => {
                    const altForm = randomExerciseContent.querySelector('.alt-form');
                    const selected = altForm.querySelector('input:checked');
                    if (selected) {
                        const selectedIndex = parseInt(selected.value);
                        const labels = altForm.querySelectorAll('label');
                        labels.forEach((label, i) => {
                            if (i === exercise.correctIndex) {
                                label.style.color = 'green';
                                label.style.fontWeight = 'bold';
                            } else if (i === selectedIndex) {
                                label.style.color = 'red';
                            } else {
                                label.style.color = '';
                            }
                        });
                        const accordion = randomExerciseContent.querySelector(`#accordion-${index}`);
                        if (accordion) accordion.classList.remove('hidden');
                    }
                });
            }
            if (limparBtn) {
                limparBtn.addEventListener('click', () => {
                    const altForm = randomExerciseContent.querySelector('.alt-form');
                    const radios = altForm.querySelectorAll('input[type="radio"]');
                    radios.forEach(radio => radio.checked = false);
                    const labels = altForm.querySelectorAll('label');
                    labels.forEach(label => {
                        label.style.color = '';
                        label.style.fontWeight = '';
                    });
                    const altTexts = altForm.querySelectorAll('.alt-text');
                    altTexts.forEach(text => text.classList.remove('rasurada'));
                    radios.forEach(radio => radio.disabled = false);
                    const accordion = randomExerciseContent.querySelector(`#accordion-${index}`);
                    if (accordion) accordion.classList.add('hidden');
                });
            }
            const rasurarBtns = randomExerciseContent.querySelectorAll('.rasurar-btn');
            rasurarBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    const altIndex = parseInt(btn.dataset.altIndex);
                    const label = btn.closest('.alt-label');
                    const altText = label.querySelector('.alt-text');
                    altText.classList.toggle('rasurada');
                    const radio = label.querySelector('input[type="radio"]');
                    radio.disabled = !radio.disabled;
                });
            });
            const accordionToggle = randomExerciseContent.querySelector('.accordion-toggle');
            if (accordionToggle) {
                accordionToggle.addEventListener('click', () => {
                    const content = accordionToggle.nextElementSibling;
                    content.classList.toggle('hidden');
                });
            }

            // Update navigation buttons
            prevRandomBtn.disabled = currentRandomIndex === 0;
            nextRandomBtn.disabled = currentRandomIndex === randomExercises.length - 1;
            randomCounter.textContent = `${currentRandomIndex + 1}/${randomExercises.length}`;
            tryResumePendingAudio();
        }

        function tryResumePendingAudio() {
            if (!pendingAudioResume) return;
            // find first audio inside the randomExerciseContent
            const a = randomExerciseContent.querySelector('audio');
            if (!a) return;
            try {
                // if src differs, set it (should be same data URL)
                if (a.src && pendingAudioResume.src && a.src !== pendingAudioResume.src) {
                    a.src = pendingAudioResume.src;
                }
                if (typeof pendingAudioResume.time === 'number') {
                    a.currentTime = pendingAudioResume.time;
                }
                if (pendingAudioResume.playing) {
                    a.play().catch(() => {});
                }
            } catch (e) {
                console.error('Erro ao tentar retomar √°udio:', e);
            }
            pendingAudioResume = null;
        }

        // Start review mode (uses the same random box but with an OK/Revisado button)
        function startReviewMode(startId) {
            const now = new Date();
            const pendingExercises = exercises.filter(e => {
                if (e.review) return true;
                if (e.nextReview) { try { return new Date(e.nextReview) <= now; } catch(e) { return false; } }
                return false;
            }) || [];
            // collect pending flashcard batches (group by batch)
            const pendingBatches = [];
            for (const b of flashcardBatches) {
                const indices = [];
                (b.cards || []).forEach((c, i) => {
                    if (!c) return;
                    const due = c.review || (c.nextReview && (() => { try { return new Date(c.nextReview) <= now; } catch(e) { return false; } })());
                    if (due) indices.push(i);
                });
                if (indices.length > 0) {
                    pendingBatches.push({ id: 'batch-' + b.id, type: 'flashcard-batch', batchId: b.id, batchName: b.name, indices: indices, batchCursor: 0 });
                }
            }
            if (pendingExercises.length === 0 && pendingBatches.length === 0) { alert('Nenhuma revis√£o pendente.'); return; }
            // combine lists (exercises first, then batches)
            randomExercises = [];
            pendingExercises.forEach(e => randomExercises.push(Object.assign({ type: 'exercise' }, e)));
            pendingBatches.forEach(b => randomExercises.push(b));
            // Try to position at provided id
            if (startId) {
                const pos = randomExercises.findIndex(x => x.id === startId);
                currentRandomIndex = pos >= 0 ? pos : 0;
            } else {
                currentRandomIndex = 0;
            }
            isReviewMode = true;
            isRandomMode = true;
            if (reviewOkBtn) reviewOkBtn.style.display = 'inline-block';
            randomModeBtn.classList.add('active');
            randomExerciseContainer.classList.add('show');
            exerciseList.style.display = 'none';
            document.getElementById('pagination').style.display = 'none';
            displayRandomExercise();
            updateReviewIndicator();
        }

        function closeReviewMode() {
            isReviewMode = false;
            if (reviewOkBtn) reviewOkBtn.style.display = 'none';
            closeRandomMode();
        }

        // Handle OK/Revisado button: mark current item as reviewed and advance
        if (reviewOkBtn) {
            reviewOkBtn.addEventListener('click', () => {
                if (!randomExercises || randomExercises.length === 0) return;
                const current = randomExercises[currentRandomIndex];
                if (!current) return;
                // mark reviewed depending on type
                if (current.type === 'flashcard-batch') {
                    // mark entire batch (the indices array) as reviewed
                    const bidx = flashcardBatches.findIndex(bb => bb.id === current.batchId);
                    if (bidx !== -1) {
                        const batch = flashcardBatches[bidx];
                        (current.indices || []).forEach(ci => {
                            if (batch.cards && batch.cards[ci]) batch.cards[ci].review = false;
                        });
                        saveFlashcardBatches();
                    }
                } else if (current.type === 'flashcard') {
                    const b = flashcardBatches.find(bb => bb.id === current.batchId);
                    if (b && b.cards && b.cards[current.cardIndex]) {
                        b.cards[current.cardIndex].review = false;
                        saveFlashcardBatches();
                    }
                } else {
                    const idx = exercises.findIndex(e => e.id === current.id);
                    if (idx !== -1) {
                        exercises[idx].review = false;
                        exercises[idx].updatedAt = new Date().toISOString();
                        localStorage.setItem('exercises', JSON.stringify(exercises));
                    }
                }
                // Remove the current item from the queue
                randomExercises.splice(currentRandomIndex, 1);
                // If no more items, close review mode
                if (!randomExercises || randomExercises.length === 0) {
                    updateReviewIndicator();
                    closeReviewMode();
                    return;
                }
                // Ensure currentRandomIndex is within bounds
                if (currentRandomIndex >= randomExercises.length) {
                    currentRandomIndex = randomExercises.length - 1;
                }
                // Show next item and refresh indicator
                displayRandomExercise();
                updateReviewIndicator();
            });
        }
    </script>
</body>
</html>